var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var BlockComponent_1;
import { Injectable, Component, DivisionAbstractComponent, FormatEffect, BrComponent, Interceptor, InlineFormatter, TBSelection, VElement, MarkdownSupport } from '@textbus/core';
class BlockComponentLoader {
    match(component) {
        return BlockComponent.blockTags.includes(component.nodeName.toLowerCase());
    }
    read(el) {
        const component = new BlockComponent(el.tagName.toLocaleLowerCase());
        return {
            component: component,
            slotsMap: [{
                    from: el,
                    toSlot: component.slot
                }]
        };
    }
}
let BlockComponentInterceptor = class BlockComponentInterceptor {
    constructor(selection) {
        this.selection = selection;
    }
    onEnter(event) {
        const parent = event.instance.parentFragment;
        const component = new BlockComponent(event.instance.tagName === 'div' ? 'div' : 'p');
        const firstRange = this.selection.firstRange;
        const next = BlockComponent.breakingLine(firstRange.startFragment, firstRange.startIndex);
        component.slot.from(next);
        parent.insertAfter(component, event.instance);
        const position = firstRange.findFirstPosition(component.slot);
        firstRange.setPosition(position.fragment, position.index);
        event.stopPropagation();
    }
};
BlockComponentInterceptor = __decorate([
    Injectable(),
    __metadata("design:paramtypes", [TBSelection])
], BlockComponentInterceptor);
let BlockComponentMarkdownSupport = class BlockComponentMarkdownSupport {
    provide() {
        return {
            key: ' ',
            match(content) {
                return /^#{1,6}$/.test(content);
            },
            componentFactory(content) {
                return new BlockComponent('h' + content.length);
            }
        };
    }
};
BlockComponentMarkdownSupport = __decorate([
    Injectable()
], BlockComponentMarkdownSupport);
let BlockComponent = BlockComponent_1 = class BlockComponent extends DivisionAbstractComponent {
    constructor(tagName) {
        super(tagName);
    }
    static breakingLine(fragment, index) {
        if (index === 0) {
            fragment.insert(new BrComponent(), 0);
            index = 1;
        }
        const next = fragment.cut(index);
        if (next.length === 0) {
            next.append(new BrComponent());
            const contentLength = fragment.length;
            fragment.getFormatKeys().forEach(key => {
                if (key instanceof InlineFormatter) {
                    fragment.getFormatRanges(key).forEach(f => {
                        if (f.endIndex === contentLength) {
                            next.apply(key, Object.assign(Object.assign({}, f), { startIndex: 0, endIndex: 1 }));
                        }
                    });
                }
            });
        }
        if (next.length === 1 && next.getContentAtIndex(0) instanceof BrComponent) {
            BlockComponent_1.cleanedFormatters.forEach(formatter => {
                next.apply(formatter, {
                    startIndex: 0,
                    endIndex: 1,
                    effect: FormatEffect.Invalid,
                    formatData: null
                });
            });
        }
        return next;
    }
    clone() {
        const component = new BlockComponent_1(this.tagName);
        component.slot.from(this.slot.clone());
        return component;
    }
    slotRender(isOutputMode, slotRendererFn) {
        return slotRendererFn(this.slot, new VElement(this.tagName));
    }
    render(isOutputMode, slotRendererFn) {
        return slotRendererFn(this.slot);
    }
};
BlockComponent.blockTags = 'div,p,h1,h2,h3,h4,h5,h6,blockquote,article,section,nav,header,footer'.split(',');
BlockComponent.cleanedFormatters = [];
BlockComponent = BlockComponent_1 = __decorate([
    Component({
        loader: new BlockComponentLoader(),
        providers: [{
                provide: Interceptor,
                useClass: BlockComponentInterceptor
            }, {
                provide: MarkdownSupport,
                useClass: BlockComponentMarkdownSupport
            }],
        styles: [
            `blockquote {padding: 10px 15px; border-left: 10px solid #dddee1; background-color: #f8f8f9; margin: 1em 0; border-radius: 4px;}`
        ]
    }),
    __metadata("design:paramtypes", [String])
], BlockComponent);
export { BlockComponent };
//# sourceMappingURL=block.component.js.map