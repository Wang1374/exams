var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var ListComponent_1;
import { Injectable, BranchAbstractComponent, Fragment, VElement, Component, Interceptor, TBSelection, BrComponent, DynamicKeymap, MarkdownSupport } from '@textbus/core';
import { BlockComponent } from './block.component';
class ListComponentLoader {
    constructor(tagNames) {
        this.tagNames = tagNames;
    }
    match(component) {
        return this.tagNames.includes(component.nodeName.toLowerCase());
    }
    read(el) {
        const component = new ListComponent(el.tagName.toLowerCase());
        const childrenSlots = [];
        const childNodes = Array.from(el.childNodes);
        while (childNodes.length) {
            const slot = new Fragment();
            let first = childNodes.shift();
            let newLi;
            while (first) {
                if (/^li$/i.test(first.nodeName)) {
                    component.slots.push(slot);
                    childrenSlots.push({
                        from: first,
                        toSlot: slot
                    });
                    break;
                }
                if (!newLi) {
                    if (first.nodeType === Node.TEXT_NODE && (/^\s+$/.test(first.textContent) || first.textContent === '')) {
                        break;
                    }
                    newLi = document.createElement('li');
                }
                newLi.appendChild(first);
                first = childNodes.shift();
            }
            if (newLi) {
                component.slots.push(slot);
                childrenSlots.push({
                    from: newLi,
                    toSlot: slot
                });
                newLi = null;
            }
        }
        return {
            component: component,
            slotsMap: childrenSlots
        };
    }
}
let ListComponentDynamicKeymap = class ListComponentDynamicKeymap {
    constructor(selection) {
        this.selection = selection;
    }
    provide(instance) {
        return [{
                keymap: {
                    key: 'Tab'
                },
                action: () => {
                    const firstRange = this.selection.firstRange;
                    const startFragment = this.getFragmentsInList(instance, firstRange.startFragment);
                    const endFragment = this.getFragmentsInList(instance, firstRange.endFragment);
                    const startIndex = instance.slots.indexOf(startFragment);
                    const endIndex = instance.slots.indexOf(endFragment);
                    const childList = new ListComponent(instance.tagName);
                    childList.slots.push(...instance.slots.splice(startIndex, endIndex - startIndex + 1));
                    const newSlot = new Fragment();
                    newSlot.append(childList);
                    instance.slots.splice(startIndex, 0, newSlot);
                }
            }];
    }
    getFragmentsInList(instance, fragment) {
        if (instance.slots.includes(fragment)) {
            return fragment;
        }
        return this.getFragmentsInList(instance, fragment.parentComponent.parentFragment);
    }
};
ListComponentDynamicKeymap = __decorate([
    Injectable(),
    __metadata("design:paramtypes", [TBSelection])
], ListComponentDynamicKeymap);
let ListComponentInterceptor = class ListComponentInterceptor {
    constructor(selection) {
        this.selection = selection;
    }
    onEnter(event) {
        event.stopPropagation();
        const slot = this.selection.commonAncestorFragment;
        const instance = event.instance;
        const firstRange = this.selection.firstRange;
        const index = instance.slots.indexOf(slot);
        if (slot === instance.slots[instance.slots.length - 1] && index !== 0) {
            const lastContent = slot.getContentAtIndex(slot.length - 1);
            if (slot.length === 0 ||
                slot.length === 1 && lastContent instanceof BrComponent) {
                instance.slots.pop();
                const parentFragment = instance.parentFragment;
                const p = new BlockComponent('p');
                p.slot.from(new Fragment());
                p.slot.append(new BrComponent());
                parentFragment.insertAfter(p, instance);
                firstRange.setStart(p.slot, 0);
                firstRange.collapse();
                return;
            }
        }
        const next = BlockComponent.breakingLine(slot, firstRange.startIndex);
        instance.slots.splice(index + 1, 0, next);
        firstRange.setPosition(next, 0);
    }
};
ListComponentInterceptor = __decorate([
    Injectable(),
    __metadata("design:paramtypes", [TBSelection])
], ListComponentInterceptor);
let ListComponentMarkdownSupport = class ListComponentMarkdownSupport {
    provide() {
        return {
            key: ' ',
            match: /^(1\.|[-+*])$/,
            componentFactory(content) {
                const tagName = /[-+*]/.test(content) ? 'ul' : 'ol';
                const component = new ListComponent(tagName);
                component.slots.push(new Fragment());
                return component;
            }
        };
    }
};
ListComponentMarkdownSupport = __decorate([
    Injectable()
], ListComponentMarkdownSupport);
let ListComponent = ListComponent_1 = class ListComponent extends BranchAbstractComponent {
    constructor(tagName) {
        super(tagName);
    }
    clone() {
        const component = new ListComponent_1(this.tagName);
        this.slots.forEach(f => {
            component.slots.push(f.clone());
        });
        return component;
    }
    slotRender(slot, isOutputMode, slotRendererFn) {
        const li = new VElement('li');
        return slotRendererFn(slot, li);
    }
    render(isOutputMode, slotRendererFn) {
        return new VElement(this.tagName, {
            childNodes: this.slots.map(i => slotRendererFn(i))
        });
    }
    split(startIndex, endIndex) {
        return {
            before: this.slots.slice(0, startIndex),
            center: this.slots.slice(startIndex, endIndex),
            after: this.slots.slice(endIndex)
        };
    }
};
ListComponent = ListComponent_1 = __decorate([
    Component({
        loader: new ListComponentLoader(['ul', 'ol']),
        providers: [{
                provide: Interceptor,
                useClass: ListComponentInterceptor
            }, {
                provide: DynamicKeymap,
                useClass: ListComponentDynamicKeymap
            }, {
                provide: MarkdownSupport,
                useClass: ListComponentMarkdownSupport
            }]
    }),
    __metadata("design:paramtypes", [String])
], ListComponent);
export { ListComponent };
//# sourceMappingURL=list.component.js.map