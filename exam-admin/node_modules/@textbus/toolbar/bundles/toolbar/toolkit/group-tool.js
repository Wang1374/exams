import { Subject } from 'rxjs';
import { UIKit } from '../_utils/uikit';
import { HighlightState } from '../help';
export var MenuType;
(function (MenuType) {
    MenuType[MenuType["Action"] = 0] = "Action";
    MenuType[MenuType["Select"] = 1] = "Select";
    MenuType[MenuType["ActionSheet"] = 2] = "ActionSheet";
    MenuType[MenuType["Dropdown"] = 3] = "Dropdown";
    MenuType[MenuType["Form"] = 4] = "Form";
})(MenuType || (MenuType = {}));
export class GroupTool {
    constructor(config) {
        this.config = config;
        this.subs = [];
    }
    create(params, addTool) {
        const { i18n, uploader, dialog, limitElement } = params;
        const config = Object.assign(Object.assign({}, this.config), { label: typeof this.config.label === 'function' ? this.config.label(i18n) : this.config.label, tooltip: typeof this.config.tooltip === 'function' ? this.config.tooltip(i18n) : this.config.tooltip });
        const subject = new Subject();
        const obs = subject.asObservable();
        const menus = config.menu.map(c => {
            switch (c.type) {
                case MenuType.Action:
                    return this.createButton(c, i18n);
                case MenuType.Select:
                    return this.createSelect(c, i18n, limitElement);
                case MenuType.ActionSheet:
                    return this.createActions(c, i18n, limitElement);
                case MenuType.Dropdown:
                    return this.createDropdown(c, i18n, limitElement);
                case MenuType.Form:
                    return this.createForm(c, i18n, dialog, uploader);
            }
        });
        menus.forEach(i => {
            addTool(i.tool);
            this.subs.push(i.tool.onAction.subscribe(() => {
                subject.next();
            }));
        });
        const dropdown = UIKit.menu({
            label: config.label,
            classes: config.classes,
            iconClasses: config.iconClasses,
            tooltip: config.tooltip,
            stickyElement: limitElement,
            menu: menus.map(i => i.viewer)
        });
        this.dropdown = dropdown;
        addTool({
            matcher: config.matcher,
            commander: null,
            keymaps: [],
            onAction: obs,
            refreshState(selectionMatchState) {
                dropdown.disabled = selectionMatchState.state === HighlightState.Disabled;
            }
        });
        return dropdown.elementRef;
    }
    onDestroy() {
        this.subs.forEach(i => i.unsubscribe());
    }
    createButton(config, i18n) {
        const subject = new Subject();
        const obs = subject.asObservable();
        const item = UIKit.formMenu({
            label: typeof config.label === 'function' ? config.label(i18n) : config.label,
            classes: config.classes,
            iconClasses: config.iconClasses,
            keymap: config.keymap,
            onChecked() {
                subject.next();
            }
        });
        return {
            viewer: item.elementRef,
            tool: {
                commander: config.commanderFactory(),
                onAction: obs,
                keymaps: config.keymap ? [{
                        keymap: config.keymap,
                        action() {
                            if (!item.disabled) {
                                subject.next();
                            }
                        }
                    }] : [],
                matcher: config.matcher,
                refreshState(selectionMatchState) {
                    switch (selectionMatchState.state) {
                        case HighlightState.Highlight:
                            item.highlight = true;
                            break;
                        case HighlightState.Normal:
                            item.disabled = false;
                            item.highlight = false;
                            break;
                        case HighlightState.Disabled:
                            item.disabled = true;
                            break;
                    }
                }
            }
        };
    }
    createSelect(c, i18n, stickyElement) {
        const config = Object.assign(Object.assign({}, c), { label: typeof c.label === 'function' ? c.label(i18n) : c.label });
        const map = new Map();
        const subject = new Subject();
        const obs = subject.asObservable();
        const selectMenu = UIKit.selectMenu({
            stickyElement,
            classes: config.classes,
            iconClasses: config.iconClasses,
            options: config.options.map(option => {
                const uiSelectOption = Object.assign(Object.assign({}, option), { label: typeof option.label === 'function' ? option.label(i18n) : option.label });
                map.set(option, uiSelectOption);
                return uiSelectOption;
            }),
            label: config.label,
            onSelected: (value) => {
                subject.next(value);
                this.dropdown.hide();
            }
        });
        return {
            viewer: selectMenu.elementRef,
            tool: {
                matcher: config.matcher,
                commander: config.commanderFactory(),
                keymaps: config.options.filter(i => i.keymap).map(option => {
                    return {
                        keymap: option.keymap,
                        action() {
                            if (!selectMenu.disabled) {
                                subject.next(option.value);
                            }
                        }
                    };
                }),
                onAction: obs,
                refreshState(selectionMatchState) {
                    var _a;
                    if (selectionMatchState.matchData) {
                        const option = (_a = config.matchOption) === null || _a === void 0 ? void 0 : _a.call(config, selectionMatchState.matchData);
                        if (option) {
                            selectMenu.disabled = false;
                            selectMenu.highlight(map.get(option));
                            return;
                        }
                    }
                    selectMenu.disabled = selectionMatchState.state === HighlightState.Disabled;
                    selectMenu.highlight(null);
                }
            }
        };
    }
    createActions(c, i18n, stickyElement) {
        const config = Object.assign(Object.assign({}, c), { label: typeof c.label === 'function' ? c.label(i18n) : c.label, tooltip: typeof c.tooltip === 'function' ? c.tooltip(i18n) : c.tooltip });
        const subject = new Subject();
        const obs = subject.asObservable();
        const selectMenu = UIKit.actionSheetMenu({
            stickyElement,
            classes: config.classes,
            iconClasses: config.iconClasses,
            actions: config.actions.map(c => {
                return Object.assign(Object.assign({}, c), { label: typeof c.label === 'function' ? c.label(i18n) : c.label, onChecked: () => {
                        subject.next(c.value);
                        this.dropdown.hide();
                    } });
            }),
            label: config.label
        });
        return {
            viewer: selectMenu.elementRef,
            tool: {
                commander: config.commanderFactory(),
                onAction: obs,
                matcher: config.matcher,
                keymaps: config.actions.filter(i => i.keymap).map(action => {
                    return {
                        keymap: action.keymap,
                        action() {
                            if (!selectMenu.disabled) {
                                subject.next(action.value);
                            }
                        }
                    };
                }),
                refreshState(selectionMatchState) {
                    selectMenu.disabled = selectionMatchState.state === HighlightState.Disabled;
                }
            }
        };
    }
    createDropdown(c, i18n, stickyElement) {
        const config = Object.assign(Object.assign({}, c), { label: typeof c.label === 'function' ? c.label(i18n) : c.label });
        const subject = new Subject();
        const obs = subject.asObservable();
        let prevValue = null;
        const menu = config.viewFactory(i18n);
        const dropdownMenu = UIKit.dropdownMenu({
            stickyElement,
            classes: config.classes,
            keymap: config.keymap,
            iconClasses: config.iconClasses,
            menu: menu.elementRef,
            label: config.label
        });
        this.subs.push(menu.onComplete.subscribe(value => {
            prevValue = value;
            subject.next(value);
            this.dropdown.hide();
        }));
        return {
            viewer: dropdownMenu.elementRef,
            tool: {
                matcher: config.matcher,
                commander: config.commanderFactory(),
                keymaps: config.keymap ? [{
                        keymap: config.keymap,
                        action() {
                            if (!dropdownMenu.disabled) {
                                subject.next(prevValue);
                            }
                        }
                    }] : [],
                onAction: obs,
                refreshState(selectionMatchState) {
                    var _a;
                    (_a = menu.update) === null || _a === void 0 ? void 0 : _a.call(menu, selectionMatchState.matchData);
                    dropdownMenu.disabled = selectionMatchState.state === HighlightState.Disabled;
                }
            }
        };
    }
    createForm(c, i18n, dialog, fileUploader) {
        const config = Object.assign(Object.assign({}, c), { label: typeof c.label === 'function' ? c.label(i18n) : c.label, tooltip: typeof c.tooltip === 'function' ? c.tooltip(i18n) : c.tooltip });
        const subject = new Subject();
        const obs = subject.asObservable();
        const menu = c.viewFactory(i18n);
        if (typeof menu.setFileUploader === 'function') {
            menu.setFileUploader(fileUploader);
        }
        let prevValue = null;
        const formMenu = UIKit.formMenu(Object.assign(Object.assign({}, config), { onChecked: () => {
                var _a;
                dialog.dialog(menu.elementRef);
                this.dropdown.hide();
                const subscription = menu.onComplete.subscribe(value => {
                    dialog.close();
                    prevValue = value;
                    subject.next(value);
                    subscription.unsubscribe();
                });
                const b = (_a = menu.onClose) === null || _a === void 0 ? void 0 : _a.subscribe(() => {
                    b.unsubscribe();
                    subscription.unsubscribe();
                    dialog.close();
                });
                this.subs.push(subscription);
                if (b) {
                    this.subs.push(b);
                }
            } }));
        return {
            viewer: formMenu.elementRef,
            tool: {
                matcher: config.matcher,
                commander: config.commanderFactory(),
                onAction: obs,
                keymaps: config.keymap ? [{
                        keymap: config.keymap,
                        action() {
                            if (!formMenu.disabled) {
                                subject.next(prevValue);
                            }
                        }
                    }] : [],
                refreshState(selectionMatchState) {
                    var _a;
                    (_a = menu.update) === null || _a === void 0 ? void 0 : _a.call(menu, selectionMatchState.matchData);
                    switch (selectionMatchState.state) {
                        case HighlightState.Highlight:
                            formMenu.disabled = false;
                            formMenu.highlight = true;
                            break;
                        case HighlightState.Normal:
                            formMenu.disabled = false;
                            formMenu.highlight = false;
                            break;
                        case HighlightState.Disabled:
                            formMenu.disabled = true;
                            formMenu.highlight = false;
                            break;
                    }
                }
            }
        };
    }
}
//# sourceMappingURL=group-tool.js.map