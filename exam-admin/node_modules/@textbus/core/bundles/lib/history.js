var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var TBHistory_1;
import { Subject } from 'rxjs';
import { sampleTime } from 'rxjs/operators';
import { forwardRef, Inject, Injectable } from '@tanbo/di';
import { BackboneAbstractComponent, BranchAbstractComponent, DivisionAbstractComponent, Renderer, TBRange, TBSelection } from './core/_api';
import { EDITABLE_DOCUMENT, EDITOR_OPTIONS } from './inject-tokens';
import { RootComponent } from './root-component';
import { EditorController } from './editor-controller';
import { makeError } from './_utils/make-error';
const historyErrorFn = makeError('History');
/**
 * TextBus 历史记录管理类
 */
let TBHistory = TBHistory_1 = class TBHistory {
    constructor(options, selection, context, renderer, editorController, rootComponent) {
        this.options = options;
        this.selection = selection;
        this.context = context;
        this.renderer = renderer;
        this.editorController = editorController;
        this.rootComponent = rootComponent;
        this.historySequence = [];
        this.historyIndex = 0;
        this.historyChangeEvent = new Subject();
        this.historyUsedEvent = new Subject();
        this.historyStackSize = options.historyStackSize || 50;
        this.onChange = this.historyChangeEvent.asObservable();
        this.onUsed = this.historyUsedEvent.asObservable();
    }
    /** 是否可返回上一次历史记录 */
    get canBack() {
        return this.historySequence.length > 0 && this.historyIndex > 0;
    }
    /** 是否可重做 */
    get canForward() {
        return this.historySequence.length > 0 && this.historyIndex < this.historySequence.length - 1;
    }
    /**
     * 应用前一次历史记录
     */
    back() {
        if (this.canBack) {
            this.historyIndex--;
            this.historyIndex = Math.max(0, this.historyIndex);
            const snapshot = TBHistory_1.cloneHistoryData(this.historySequence[this.historyIndex]);
            this.rootComponent.slot.from(snapshot.component.slot);
            this.usePaths(snapshot.paths, this.rootComponent.slot);
            this.listen();
            this.historyUsedEvent.next();
        }
    }
    /**
     * 重做
     */
    forward() {
        if (this.canForward) {
            this.historyIndex++;
            const snapshot = TBHistory_1.cloneHistoryData(this.historySequence[this.historyIndex]);
            this.rootComponent.slot.from(snapshot.component.slot);
            this.usePaths(snapshot.paths, this.rootComponent.slot);
            this.listen();
            this.historyUsedEvent.next();
        }
    }
    /**
     * 销毁当前历史记录
     */
    destroy() {
        var _a;
        this.historySequence = null;
        (_a = this.stateChangeSubscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();
        this.stopListen();
    }
    /**
     * 清除历史记录
     */
    clean() {
        this.historyIndex = 0;
        this.historySequence = [];
    }
    /**
     * 开始记录历史
     */
    record() {
        this.recordSnapshot();
        this.listen();
    }
    stopListen() {
        if (this.snapshotSubscription) {
            this.snapshotSubscription.unsubscribe();
        }
    }
    listen() {
        this.stopListen();
        this.snapshotSubscription = this.rootComponent.onChange.pipe(sampleTime(5000)).subscribe(() => {
            this.recordSnapshot();
        });
    }
    recordSnapshot() {
        if (this.historySequence.length !== this.historyIndex) {
            this.historySequence.length = this.historyIndex + 1;
        }
        this.historySequence.push({
            component: this.rootComponent.clone(),
            paths: this.getRangePaths()
        });
        if (this.historySequence.length > this.historyStackSize) {
            this.historySequence.shift();
        }
        this.historyIndex = this.historySequence.length - 1;
        this.historyChangeEvent.next();
    }
    static cloneHistoryData(snapshot) {
        return {
            component: snapshot.component.clone(),
            paths: snapshot.paths.map(i => i)
        };
    }
    /**
     * 获取当前 Selection 所有 Range 的 path
     */
    getRangePaths() {
        const getPaths = (fragment) => {
            const paths = [];
            while (fragment) {
                const parentComponent = fragment.parentComponent;
                if (!parentComponent.parentFragment) {
                    break;
                }
                if (parentComponent instanceof BranchAbstractComponent) {
                    paths.push(parentComponent.slots.indexOf(fragment));
                }
                else if (parentComponent instanceof BackboneAbstractComponent) {
                    paths.push(parentComponent.indexOf(fragment));
                }
                else {
                    paths.push(0);
                }
                fragment = parentComponent.parentFragment;
                if (fragment) {
                    paths.push(fragment.indexOf(parentComponent));
                }
            }
            return paths.reverse();
        };
        return this.selection.ranges.map(range => {
            const paths = getPaths(range.startFragment);
            paths.push(range.startIndex);
            if (range.collapsed) {
                return {
                    startPaths: paths,
                    endPaths: paths
                };
            }
            else {
                const endPaths = getPaths(range.endFragment);
                endPaths.push(range.endIndex);
                return {
                    startPaths: paths,
                    endPaths
                };
            }
        });
    }
    /**
     * 将一组路径应用到当前 Selection
     * @param paths
     * @param fragment
     */
    usePaths(paths, fragment) {
        const findPosition = (position, fragment) => {
            const paths = position.map(i => i).reverse();
            while (true) {
                const index = paths.pop();
                if (paths.length === 0) {
                    return {
                        fragment,
                        index
                    };
                }
                const c = fragment.getContentAtIndex(index);
                const last = paths.pop();
                if (c instanceof DivisionAbstractComponent && last === 0) {
                    fragment = c.slot;
                }
                else if (c instanceof BranchAbstractComponent) {
                    fragment = c.slots[last];
                }
                else if (c instanceof BackboneAbstractComponent) {
                    fragment = c.getSlotAtIndex(last);
                }
                else {
                    throw historyErrorFn('location of the history range could not be found.');
                }
                if (paths.length === 1) {
                    return {
                        fragment,
                        index: paths.pop()
                    };
                }
            }
        };
        let nativeRange;
        if (this.selection.nativeSelection.rangeCount) {
            nativeRange = this.selection.nativeSelection.getRangeAt(0);
        }
        else {
            nativeRange = this.context.createRange();
        }
        const len = paths.length;
        if (len === 0) {
            return;
        }
        const startPaths = paths[0].startPaths;
        const endPaths = paths[len - 1].endPaths;
        const start = findPosition(startPaths, fragment);
        const range = new TBRange(nativeRange, this.renderer);
        range.setStart(start.fragment, start.index);
        if (endPaths === startPaths) {
            range.setEnd(start.fragment, start.index);
        }
        else {
            const end = findPosition(endPaths, fragment);
            range.setEnd(end.fragment, end.index);
        }
        this.selection.removeAllRanges();
        this.selection.addRange(range);
    }
};
TBHistory = TBHistory_1 = __decorate([
    Injectable(),
    __param(0, Inject(forwardRef(() => EDITOR_OPTIONS))),
    __param(1, Inject(forwardRef(() => TBSelection))),
    __param(2, Inject(forwardRef(() => EDITABLE_DOCUMENT))),
    __param(3, Inject(forwardRef(() => Renderer))),
    __param(4, Inject(forwardRef(() => EditorController))),
    __param(5, Inject(forwardRef(() => RootComponent))),
    __metadata("design:paramtypes", [Object, TBSelection,
        Document,
        Renderer,
        EditorController,
        RootComponent])
], TBHistory);
export { TBHistory };
//# sourceMappingURL=history.js.map