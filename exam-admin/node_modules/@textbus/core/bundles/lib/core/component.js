var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var _a;
var BrComponent_1;
import { Fragment, parentComponentAccessToken } from './fragment';
import { VElement } from './element';
import { Marker } from './marker';
import { Component } from './di/component';
/**
 * 当 TextBus 需要把一段文本转换为抽象数据时使用，用于把 DOM 树转换为抽象的 Component 和 Fragment 的类。
 */
export class ComponentLoader {
}
export const parentFragmentAccessToken = Symbol('ParentFragmentAccessToken');
/**
 * TextBus 组件基类，不可直接继承 Component 类。
 * 如要扩展功能。请继承 DivisionAbstractComponent、BranchAbstractComponent、BackboneAbstractComponent 或 LeafAbstractComponent 类。
 */
export class AbstractComponent extends Marker {
    constructor(tagName) {
        super();
        this.tagName = tagName;
        this[_a] = null;
        /**
         * 在 TextBus 中，视所有模板为一个单独的个体，且规定长度为 1。
         */
        this.length = 1;
        this.canDispatchDataChange = true;
        this.canDispatchContentChange = true;
    }
    get parentFragment() {
        return this[parentFragmentAccessToken];
    }
    markAsDirtied() {
        if (this.canDispatchDataChange === false) {
            return;
        }
        if (typeof this.componentDataChange === 'function') {
            this.canDispatchDataChange = false;
            this.componentDataChange();
            this.canDispatchDataChange = true;
        }
        super.markAsDirtied();
    }
    markAsChanged() {
        if (this.canDispatchContentChange === false) {
            return;
        }
        if (typeof this.componentContentChange === 'function') {
            this.canDispatchContentChange = false;
            this.componentContentChange();
            this.canDispatchContentChange = true;
        }
        super.markAsChanged();
    }
}
_a = parentFragmentAccessToken;
/**
 * 只有一个子插槽的组件，如 p、div、h1~h6、blockquote 等，也可以是用户自定义的只有一个子插槽的组件。
 * 需要注意的是，组件内部的结构是不可以通过用户编辑的。
 */
export class DivisionAbstractComponent extends AbstractComponent {
    constructor(tagName) {
        super(tagName);
        this.slot = new Fragment();
        this.slot[parentComponentAccessToken] = this;
        this.slot.onChange.subscribe(() => {
            this.markAsChanged();
        });
    }
}
/**
 * 有任意个子插槽，且子插槽可以任意增删的组件。
 * 如 ul、ol 等，都保持一个固定的结构，但 li 的个数是不限制的，且是可以更改的。也可以用户自定义的组件。
 * 需要注意的是，组件内部的结构是不可以通过用户编辑的。
 */
export class BranchAbstractComponent extends AbstractComponent {
    constructor() {
        super(...arguments);
        this.eventMap = new Map();
        /**
         * 子插槽的集合
         */
        this.slots = new Proxy([], {
            set: (target, p, value, receiver) => {
                if (value instanceof Fragment) {
                    if (!value.dirty && !target.includes(value)) {
                        value.markAsDirtied();
                    }
                    if (!this.eventMap.has(value)) {
                        this.eventMap.set(value, value.onChange.subscribe(() => {
                            this.markAsChanged();
                        }));
                    }
                }
                if (p === 'length' && typeof value === 'number') {
                    for (const item of target) {
                        if (item) {
                            item[parentComponentAccessToken] = null;
                        }
                    }
                }
                const b = Reflect.set(target, p, value, receiver);
                this.eventMap.forEach(v => v.unsubscribe());
                this.eventMap.clear();
                target.forEach(f => {
                    this.eventMap.set(f, f.onChange.subscribe(() => {
                        this.markAsChanged();
                    }));
                    f[parentComponentAccessToken] = this;
                });
                this.markAsDirtied();
                return b;
            },
            deleteProperty: (target, p) => {
                var _b;
                const deletedValue = target[p];
                const b = Reflect.deleteProperty(target, p);
                if (typeof p === 'string' && /\d+/.test(p) && deletedValue && !target.includes(deletedValue)) {
                    (_b = this.eventMap.get(deletedValue)) === null || _b === void 0 ? void 0 : _b.unsubscribe();
                    this.eventMap.delete(deletedValue);
                    deletedValue[parentComponentAccessToken] = null;
                    this.markAsDirtied();
                }
                return b;
            }
        });
    }
}
/**
 * 有任意个子插槽，且子插槽不可随意更改的组件。
 * 如 table，可以有多个 td，但 td 是不能随意删除的，否则会破坏 table 的结构。
 */
export class BackboneAbstractComponent extends AbstractComponent {
    constructor() {
        super(...arguments);
        /**
         * 子插槽的集合
         */
        this.eventMap = new Map();
        this.slots = [];
        this.iteratorIndex = 0;
    }
    get slotCount() {
        return this.slots.length;
    }
    [Symbol.iterator]() {
        this.iteratorIndex = 0;
        return this;
    }
    next() {
        if (this.iteratorIndex < this.slotCount) {
            const value = this.slots[this.iteratorIndex];
            this.iteratorIndex++;
            return {
                done: false,
                value
            };
        }
        return {
            done: true,
            value: undefined
        };
    }
    getSlotAtIndex(index) {
        return this.slots[index];
    }
    indexOf(fragment) {
        return this.slots.indexOf(fragment);
    }
    forEach(callbackFn, thisArg) {
        this.slots.forEach(callbackFn, thisArg);
    }
    clean() {
        this.slots.forEach(f => {
            f[parentComponentAccessToken] = null;
            this.eventMap.get(f).unsubscribe();
        });
        this.eventMap.clear();
        this.slots = [];
    }
    push(...fragments) {
        this.setup(fragments);
        this.slots.push(...fragments);
        this.markAsDirtied();
    }
    pop() {
        const f = this.slots.pop();
        if (f) {
            f[parentComponentAccessToken] = null;
            this.eventMap.get(f).unsubscribe();
            this.eventMap.delete(f);
        }
        this.markAsDirtied();
        return f;
    }
    splice(start, deleteCount, ...items) {
        const deletedSlots = this.slots.splice(start, deleteCount, ...items);
        deletedSlots.forEach(f => {
            f[parentComponentAccessToken] = null;
            this.eventMap.get(f).unsubscribe();
            this.eventMap.delete(f);
        });
        if (items) {
            this.setup(items);
        }
        this.markAsDirtied();
        return deletedSlots;
    }
    map(callbackFn, thisArg) {
        return this.slots.map(callbackFn, thisArg);
    }
    setup(fragments) {
        fragments.forEach(f => {
            f[parentComponentAccessToken] = this;
            if (!f.dirty && !this.slots.includes(f)) {
                f.markAsDirtied();
            }
            this.eventMap.set(f, f.onChange.subscribe(() => {
                this.markAsChanged();
            }));
        });
    }
}
/**
 * 没有子插槽的组件，如 br、img等。也可以是用户自定义的组件。
 * 需要注意的是，组件内部的结构是不可以通过用户编辑的。
 */
export class LeafAbstractComponent extends AbstractComponent {
    constructor(tagName) {
        super(tagName);
    }
}
class BrComponentLoader {
    match(component) {
        return component.nodeName.toLowerCase() === 'br';
    }
    read() {
        const component = new BrComponent();
        return {
            component: component,
            slotsMap: []
        };
    }
}
let BrComponent = BrComponent_1 = class BrComponent extends LeafAbstractComponent {
    constructor() {
        super('br');
        this.block = false;
    }
    clone() {
        return new BrComponent_1();
    }
    render() {
        return new VElement(this.tagName);
    }
};
BrComponent = BrComponent_1 = __decorate([
    Component({
        loader: new BrComponentLoader()
    }),
    __metadata("design:paramtypes", [])
], BrComponent);
export { BrComponent };
//# sourceMappingURL=component.js.map