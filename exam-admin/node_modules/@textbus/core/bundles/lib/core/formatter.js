import { FormatData } from './format-data';
/**
 * 用于标识格式在 DOM 元素上应用的状态。
 */
export var FormatEffect;
(function (FormatEffect) {
    /** 生效的 */
    FormatEffect["Valid"] = "Valid";
    /** 不生效的 */
    FormatEffect["Invalid"] = "Invalid";
    /** 排除 */
    FormatEffect["Exclude"] = "Exclude";
    /** 继承 */
    FormatEffect["Inherit"] = "Inherit";
})(FormatEffect || (FormatEffect = {}));
/**
 * 标识格式渲染优先级。
 */
export var FormatterPriority;
(function (FormatterPriority) {
    FormatterPriority[FormatterPriority["BlockStyle"] = 0] = "BlockStyle";
    FormatterPriority[FormatterPriority["InlineTag"] = 100] = "InlineTag";
    FormatterPriority[FormatterPriority["InlineStyle"] = 200] = "InlineStyle";
    FormatterPriority[FormatterPriority["Attribute"] = 300] = "Attribute";
})(FormatterPriority || (FormatterPriority = {}));
/**
 * TextBus 格式基类，在扩展格式时，不能直接继承 Formatter，请继承 InlineFormatter、BlockFormatter 或其它子类。
 */
export class Formatter {
    constructor(rule, priority) {
        this.rule = rule;
        this.priority = priority;
        this.inheritValidators = [];
        this.validators = [];
        this.excludeValidators = [];
        if (rule.extendTags) {
            this.inheritValidators.push(this.makeTagsMatcher(rule.extendTags));
        }
        if (rule.tags) {
            this.validators.push(this.makeTagsMatcher(rule.tags));
        }
        // if (rule.classes) {
        //   this.validators.push(this.makeClassNameMatcher(rule.classes));
        // }
        if (rule.styles) {
            this.validators.push(this.makeStyleMatcher(rule.styles));
        }
        if (rule.attrs) {
            this.validators.push(this.makeAttrsMatcher(rule.attrs));
        }
        // if (rule.excludeClasses) {
        //   this.excludeValidators.push(this.makeClassNameMatcher(rule.excludeClasses));
        // }
        if (rule.excludeStyles) {
            this.excludeValidators.push(this.makeStyleMatcher(rule.excludeStyles));
        }
        if (rule.excludeAttrs) {
            this.excludeValidators.push(this.makeAttrsMatcher(rule.excludeAttrs));
        }
    }
    /**
     * 匹配一个 DOM 节点或抽象格式数据，返回生效状态。
     * @param element
     */
    match(element) {
        if (this.rule.filter) {
            const b = this.rule.filter(element);
            if (!b) {
                return FormatEffect.Invalid;
            }
        }
        const exclude = this.excludeValidators.map(fn => fn(element)).includes(true);
        if (exclude) {
            return FormatEffect.Exclude;
        }
        const inherit = this.inheritValidators.map(fn => fn(element)).includes(true);
        if (inherit) {
            return FormatEffect.Inherit;
        }
        return this.validators.map(fn => fn(element)).includes(true) ? FormatEffect.Valid : FormatEffect.Invalid;
    }
    extractData(node, config) {
        if (!config) {
            return new FormatData();
        }
        const attrs = new Map();
        if (config.attrs) {
            config.attrs.forEach(key => {
                attrs.set(key, node.getAttribute(key));
            });
        }
        const style = {};
        if (config.styleName) {
            (Array.isArray(config.styleName) ? config.styleName : [config.styleName]).forEach(name => {
                const v = node.style[name];
                if (v) {
                    style[name] = v;
                }
            });
        }
        return new FormatData({
            tag: config.tag ? node.nodeName.toLowerCase() : null,
            attrs: attrs.size ? attrs : null,
            styles: style
        });
    }
    makeTagsMatcher(tags) {
        return (node) => {
            const tagName = node.nodeName.toLowerCase();
            return Array.isArray(tags) ? tags.includes(tagName) : tags.test(tagName);
        };
    }
    makeAttrsMatcher(attrs) {
        return (node) => {
            return attrs.map(attr => {
                if (attr.value) {
                    return node.getAttribute(attr.key) === attr.value;
                }
                return node.hasAttribute(attr.key);
            }).includes(true);
        };
    }
    makeStyleMatcher(styles) {
        return (node) => {
            return !Object.keys(styles).map(key => {
                const optionValue = (Array.isArray(styles[key]) ?
                    styles[key] :
                    [styles[key]]);
                let styleValue = node.style[key];
                if (key === 'fontFamily' && typeof styleValue === 'string') {
                    styleValue = styleValue.replace(/['"]/g, '');
                }
                if (styleValue) {
                    return optionValue.map(v => {
                        if (v instanceof RegExp) {
                            return v.test(styleValue);
                        }
                        return v === styleValue;
                    }).includes(true);
                }
                return false;
            }).includes(false);
        };
    }
}
/**
 * 行内样式基类，用于扩展行内样式。
 */
export class InlineFormatter extends Formatter {
}
export class BlockFormatter extends Formatter {
}
//# sourceMappingURL=formatter.js.map