/**
 * 抽象数据类，用于记录一个节点或样式的摘要数据
 */
export class FormatData {
    constructor(params = {}) {
        this.attrs = new Map();
        this.styles = new Map();
        this.classes = [];
        this.tag = params.tag;
        if (params.attrs) {
            if (params.attrs instanceof Map) {
                this.attrs = params.attrs;
            }
            else {
                this.attrs = new Map();
                Object.keys(params.attrs).forEach(key => {
                    this.attrs.set(key, params.attrs[key]);
                });
            }
        }
        if (params.styles) {
            if (params.styles instanceof Map) {
                this.styles = params.styles;
            }
            else {
                this.styles = new Map();
                Object.keys(params.styles).forEach(key => {
                    this.styles.set(key, params.styles[key]);
                });
            }
        }
        if (params.classes) {
            this.classes = [...params.classes];
        }
    }
    /**
     * 复制当前抽象数据的副本。
     */
    clone() {
        return new FormatData({
            tag: this.tag,
            attrs: this.attrs.size ? (() => {
                const obj = {};
                this.attrs.forEach((value, key) => {
                    obj[key] = value;
                });
                return obj;
            })() : null,
            styles: this.styles.size ? (() => {
                const obj = {};
                this.styles.forEach((value, key) => {
                    obj[key] = value;
                });
                return obj;
            })() : null,
            classes: this.classes
        });
    }
    /**
     * 判断 data 是否和自己相等。
     * @param data
     */
    equal(data) {
        if (data === this) {
            return true;
        }
        if (!data) {
            return false;
        }
        const left = data;
        return left.tag == this.tag &&
            FormatData.equalMap(left.attrs, this.attrs) &&
            FormatData.equalMap(left.styles, this.styles) &&
            FormatData.equalStringList(left.classes, this.classes);
    }
    static equalStringList(left, right) {
        if (left.length !== right.length) {
            return false;
        }
        for (const item of left) {
            if (!right.includes(item)) {
                return false;
            }
        }
        return true;
    }
    static equalMap(left, right) {
        if (left === right || !left === true && !right === true) {
            return true;
        }
        if (!left !== !right || left.size !== right.size) {
            return false;
        }
        return Array.from(left.keys()).reduce((v, key) => {
            return v && left.get(key) === right.get(key);
        }, true);
    }
}
//# sourceMappingURL=format-data.js.map