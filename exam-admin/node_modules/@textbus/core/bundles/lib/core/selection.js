import { of, Subject, merge } from 'rxjs';
import { tap } from 'rxjs/operators';
import { TBRange } from './range';
var CursorMoveDirection;
(function (CursorMoveDirection) {
    CursorMoveDirection[CursorMoveDirection["Left"] = 0] = "Left";
    CursorMoveDirection[CursorMoveDirection["Right"] = 1] = "Right";
    CursorMoveDirection[CursorMoveDirection["Up"] = 2] = "Up";
    CursorMoveDirection[CursorMoveDirection["Down"] = 3] = "Down";
})(CursorMoveDirection || (CursorMoveDirection = {}));
/**
 * TextBus 选区对象
 */
export class TBSelection {
    constructor(context, selectionChange, renderer) {
        this.context = context;
        this.selectionChange = selectionChange;
        this.renderer = renderer;
        this._ranges = [];
        this.selectionChangeEvent = new Subject();
        this.isChanged = false;
        this.oldCursorPosition = null;
        this.nativeSelection = context.getSelection();
        this.onChange = merge(selectionChange, this.selectionChangeEvent.asObservable()).pipe(tap(() => {
            this.isChanged = true;
            this._ranges = [];
            for (let i = 0; i < this.nativeSelection.rangeCount; i++) {
                const nativeRange = this.nativeSelection.getRangeAt(i);
                const startFocusNode = this.findFocusNode(nativeRange.startContainer);
                const endFocusNode = this.findFocusNode(nativeRange.endContainer);
                if (!startFocusNode || !endFocusNode || !startFocusNode.parentNode || !endFocusNode.parentNode) {
                    continue;
                }
                if (startFocusNode !== nativeRange.startContainer) {
                    const startNextSibling = startFocusNode.nextSibling;
                    if (startNextSibling && startNextSibling.nodeType === Node.TEXT_NODE) {
                        nativeRange.setStart(startNextSibling, 0);
                    }
                    else {
                        nativeRange.setStart(startFocusNode.parentNode, Array.from(startFocusNode.parentNode.childNodes).indexOf(startFocusNode) + 1);
                    }
                }
                if (endFocusNode !== nativeRange.endContainer) {
                    const endNextSibling = endFocusNode.nextSibling;
                    if (endNextSibling && endNextSibling.nodeType === Node.TEXT_NODE) {
                        nativeRange.setEnd(endNextSibling, 0);
                    }
                    else {
                        nativeRange.setEnd(endFocusNode.parentNode, Array.from(endFocusNode.parentNode.childNodes).indexOf(endFocusNode) + 1);
                    }
                }
                this._ranges.push(new TBRange(nativeRange.cloneRange(), this.renderer));
            }
        }));
    }
    /**
     * 选区范围个数。
     */
    get rangeCount() {
        return this._ranges.length;
    }
    /**
     * 所有选区范围集合。
     */
    get ranges() {
        return this._ranges;
    }
    /**
     * 所有选区的所属最近的公共 fragment。
     */
    get commonAncestorFragment() {
        return this.getCommonFragment();
    }
    get commonAncestorComponent() {
        return this.getCommonComponent();
    }
    /**
     * 获取 Selection 的第一个 Range。
     */
    get firstRange() {
        return this.ranges[0] || null;
    }
    /**
     * 获取 Selection 的最后一个 Range。
     */
    get lastRange() {
        return this.ranges[this.ranges.length - 1] || null;
    }
    /**
     * 当前 Selection 是否折叠。
     */
    get collapsed() {
        return this.ranges.length === 1 && this.firstRange.collapsed || this.ranges.length === 0;
    }
    /**
     * 通过 TBRange 复位原生选区。
     */
    restore() {
        var _a, _b;
        this.isChanged = false;
        this._ranges.forEach(range => {
            if (range.commonAncestorComponent) {
                range.restore();
            }
        });
        const startNativeRange = (_a = this.firstRange) === null || _a === void 0 ? void 0 : _a.nativeRange;
        const endNativeRange = (_b = this.lastRange) === null || _b === void 0 ? void 0 : _b.nativeRange;
        if (startNativeRange && endNativeRange) {
            let nativeRange;
            if (this.nativeSelection.rangeCount) {
                nativeRange = this.nativeSelection.getRangeAt(0);
            }
            else {
                nativeRange = this.context.createRange();
                this.nativeSelection.addRange(nativeRange);
            }
            nativeRange.setStart(startNativeRange.startContainer, startNativeRange.startOffset);
            nativeRange.setEnd(endNativeRange.endContainer, endNativeRange.endOffset);
        }
        if (!this.isChanged) {
            this.selectionChangeEvent.next();
        }
    }
    toPrevious() {
        this.moveCursor(CursorMoveDirection.Left);
    }
    toNext() {
        this.moveCursor(CursorMoveDirection.Right);
    }
    toPreviousLine() {
        this.moveCursor(CursorMoveDirection.Up);
    }
    toNextLine() {
        this.moveCursor(CursorMoveDirection.Down);
    }
    /**
     * 清除所有的 Range。
     * @param syncNative
     */
    removeAllRanges(syncNative = false) {
        if (syncNative) {
            this.nativeSelection.removeAllRanges();
        }
        this._ranges = [];
    }
    /**
     * 添加一个 Range。
     * @param range
     */
    addRange(range) {
        this._ranges.push(range);
    }
    /**
     * 创建一个新的区域
     */
    createRange() {
        return new TBRange(this.context.createRange(), this.renderer);
    }
    /**
     * 克隆当前 Selection 的副本，并返回。
     */
    clone() {
        const t = new TBSelection(this.context, of(), this.renderer);
        t._ranges = this.ranges.map(r => r.clone());
        return t;
    }
    selectAll() {
        this.nativeSelection.selectAllChildren(this.context.body);
    }
    getCommonComponent() {
        const ranges = this.ranges || [];
        if (ranges.length === 1) {
            return ranges[0].commonAncestorComponent;
        }
        const depth = [];
        ranges.map(range => range.commonAncestorComponent).forEach(component => {
            var _a;
            const tree = [];
            while (component) {
                tree.push(component);
                component = (_a = component.parentFragment) === null || _a === void 0 ? void 0 : _a.parentComponent;
            }
            depth.push(tree);
        });
        let component = null;
        while (true) {
            const firstComponents = depth.map(arr => arr.pop()).filter(i => i);
            if (firstComponents.length === depth.length) {
                if (new Set(firstComponents).size === 1) {
                    component = firstComponents[0];
                }
                else {
                    break;
                }
            }
            else {
                break;
            }
        }
        return component;
    }
    getCommonFragment() {
        const ranges = this.ranges || [];
        if (ranges.length === 1) {
            return ranges[0].commonAncestorFragment;
        }
        const depth = [];
        ranges.map(range => range.commonAncestorFragment).forEach(fragment => {
            var _a;
            const tree = [];
            while (fragment) {
                tree.push(fragment);
                fragment = (_a = fragment.parentComponent) === null || _a === void 0 ? void 0 : _a.parentFragment;
            }
            depth.push(tree);
        });
        let fragment = null;
        while (true) {
            const firstFragments = depth.map(arr => arr.pop()).filter(i => i);
            if (firstFragments.length === depth.length) {
                if (new Set(firstFragments).size === 1) {
                    fragment = firstFragments[0];
                }
                else {
                    break;
                }
            }
        }
        return fragment;
    }
    findFocusNode(node) {
        const position = this.renderer.getPositionByNode(node);
        if (!position) {
            const parentNode = node.parentNode;
            if (parentNode) {
                return this.findFocusNode(parentNode);
            }
            return null;
        }
        return node;
    }
    moveCursor(direction) {
        const range = direction === CursorMoveDirection.Down ? this.lastRange : this.firstRange;
        if (!range) {
            return;
        }
        this.removeAllRanges();
        this.addRange(range);
        let p;
        let range2;
        switch (direction) {
            case CursorMoveDirection.Left:
                p = range.getPreviousPosition();
                break;
            case CursorMoveDirection.Right:
                p = range.getNextPosition();
                break;
            case CursorMoveDirection.Up:
                clearTimeout(this.cleanOldCursorTimer);
                range2 = range.clone().restore();
                if (this.oldCursorPosition) {
                    p = range2.getPreviousLinePosition(this.oldCursorPosition.left);
                }
                else {
                    const rect = range2.getRangePosition();
                    this.oldCursorPosition = rect;
                    p = range.getPreviousLinePosition(rect.left);
                }
                this.cleanOldCursorTimer = setTimeout(() => {
                    this.oldCursorPosition = null;
                }, 3000);
                break;
            case CursorMoveDirection.Down:
                clearTimeout(this.cleanOldCursorTimer);
                range2 = range.clone().restore();
                if (this.oldCursorPosition) {
                    p = range2.getNextLinePosition(this.oldCursorPosition.left);
                }
                else {
                    const rect = range2.getRangePosition();
                    this.oldCursorPosition = rect;
                    p = range.getNextLinePosition(rect.left);
                }
                this.cleanOldCursorTimer = setTimeout(() => {
                    this.oldCursorPosition = null;
                }, 3000);
                break;
        }
        range.setPosition(p.fragment, p.index);
        this.restore();
    }
}
//# sourceMappingURL=selection.js.map