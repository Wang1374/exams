import { Fragment } from './fragment';
import { FormatEffect } from './formatter';
import { BranchAbstractComponent, DivisionAbstractComponent, BackboneAbstractComponent } from './component';
/**
 * Parser 类用于把一段 DOM 转换为组件（Component）和可编辑片段（Fragment）的抽象数据树
 */
export class Parser {
    constructor(componentLoaders = [], formatters = []) {
        this.componentLoaders = componentLoaders;
        this.formatters = formatters;
    }
    static parseHTML(html) {
        return new DOMParser().parseFromString(html, 'text/html').body;
    }
    /** @deprecated */
    static parserHTML(html) {
        return Parser.parseHTML(html);
    }
    parse(el) {
        const rootSlot = new Fragment();
        this.readComponent(el, rootSlot);
        return rootSlot;
    }
    readComponent(el, slot) {
        if (el.nodeType === Node.ELEMENT_NODE) {
            for (const t of this.componentLoaders) {
                if (t.match(el)) {
                    const viewData = t.read(el);
                    slot.append(viewData.component, false);
                    viewData.slotsMap.forEach(item => {
                        if (!item.from) {
                            return;
                        }
                        if (viewData.component instanceof DivisionAbstractComponent ||
                            viewData.component instanceof BranchAbstractComponent ||
                            viewData.component instanceof BackboneAbstractComponent ||
                            item.from === el) {
                            this.readFormats(item.from, item.toSlot);
                        }
                        else {
                            this.readComponent(item.from, item.toSlot);
                        }
                    });
                    return;
                }
            }
            this.readFormats(el, slot);
        }
        else if (el.nodeType === Node.TEXT_NODE) {
            const textContent = el.textContent;
            if (/^\s*[\r\n]+\s*$/.test(textContent)) {
                return;
            }
            slot.append(textContent, false);
        }
    }
    readFormats(el, slot) {
        const maps = this.formatters.map(f => {
            return {
                formatter: f,
                effect: f.match(el)
            };
        }).filter(p => p.effect !== FormatEffect.Invalid).map(p => {
            return Object.assign(Object.assign({}, p), { formatData: p.formatter.read(el) });
        });
        const startIndex = slot.length;
        Array.from(el.childNodes).forEach(child => {
            this.readComponent(child, slot);
        });
        maps.forEach(item => {
            slot.apply(item.formatter, {
                startIndex,
                endIndex: slot.length,
                formatData: item.formatData,
                effect: item.effect
            }, {
                important: false
            });
        });
    }
}
//# sourceMappingURL=parser.js.map