import { BlockFormatter, FormatEffect } from './formatter';
/**
 * 内部是对 Map<InlineFormatter | BlockFormatter, FormatRange[]> 的封装。
 * 并提供格式合并的功能。
 */
export class FormatMap {
    constructor() {
        this.map = new Map();
    }
    keys() {
        return this.map.keys();
    }
    get(formatter) {
        return this.map.get(formatter);
    }
    set(formatter, formatRanges) {
        this.map.set(formatter, formatRanges);
    }
    /**
     * 合并格式
     * @param token 当前格式类别
     * @param formatter 当前要合并的格式
     * @param important 合并的优先级
     */
    merge(token, formatter, important) {
        if (token instanceof BlockFormatter) {
            if (formatter.effect === FormatEffect.Invalid) {
                this.map.delete(token);
            }
            else {
                this.map.set(token, [formatter]);
            }
            return;
        }
        const oldFormats = this.map.get(token);
        if (!Array.isArray(oldFormats)) {
            if (formatter.effect !== FormatEffect.Invalid) {
                this.map.set(token, [formatter]);
            }
            return;
        }
        const newFormatMarks = [];
        const formatRanges = [];
        important ? oldFormats.push(formatter) : oldFormats.unshift(formatter);
        while (oldFormats.length) {
            const first = oldFormats.shift();
            if (newFormatMarks.length < first.endIndex) {
                newFormatMarks.length = first.endIndex;
            }
            newFormatMarks.fill(first, first.startIndex, first.endIndex);
        }
        let newFormatRange = null;
        for (let i = 0; i < newFormatMarks.length; i++) {
            const mark = newFormatMarks[i];
            if (!mark) {
                newFormatRange = null;
                continue;
            }
            if (!newFormatRange) {
                newFormatRange = {
                    startIndex: i,
                    endIndex: i + 1,
                    formatData: mark.formatData,
                    effect: mark.effect
                };
                formatRanges.push(newFormatRange);
                continue;
            }
            if (mark.effect === newFormatRange.effect && (mark.formatData &&
                newFormatRange.formatData &&
                mark.formatData.equal(newFormatRange.formatData) || !mark.formatData === true && !newFormatRange.formatData === true)) {
                newFormatRange.endIndex = i + 1;
            }
            else {
                newFormatRange = {
                    startIndex: i,
                    endIndex: i + 1,
                    formatData: mark.formatData,
                    effect: mark.effect
                };
                formatRanges.push(newFormatRange);
            }
        }
        const ff = formatRanges.filter(f => f.effect !== FormatEffect.Invalid);
        if (ff.length) {
            this.map.set(token, ff);
        }
        else {
            this.map.delete(token);
        }
    }
}
//# sourceMappingURL=format-map.js.map