import { Fragment } from './fragment';
import { VElement } from './element';
import { Marker } from './marker';
/**
 * 用于保存读取 DOM 时，Fragment 和 DOM 节点的对应关系。
 */
export interface SlotMap {
    from: HTMLElement;
    toSlot: Fragment;
}
/**
 * 用于向 Parser 返回当前组件的实例及其插槽和 DOM 节点的对应关系，以便 Parser 能够正常的向下读取 DOM 树。
 */
export interface ViewData {
    component: AbstractComponent;
    slotsMap: SlotMap[];
}
/**
 * 当 TextBus 需要把一段文本转换为抽象数据时使用，用于把 DOM 树转换为抽象的 Component 和 Fragment 的类。
 */
export declare abstract class ComponentLoader {
    /**
     * 匹配一个 DOM 节点或 DOM 片段，如果为 true，则 Parser 会接着调用 read 方法，获取转换后的抽象数据。
     * @param element 当前要匹配的元素。
     */
    abstract match(element: HTMLElement): boolean;
    /**
     * 用于将一个 DOM 节点或 DOM 树，转换为抽象的 Component，并返回子插槽和后代 DOM 节点的映射关系。
     * @param element 当前要转换的元素。
     */
    abstract read(element: HTMLElement): ViewData;
}
export declare const parentFragmentAccessToken: unique symbol;
export declare type SlotRenderFn = (slot: Fragment) => VElement;
export declare type SingleSlotRenderFn = (slot: Fragment, contentContainer: VElement) => VElement;
export interface AbstractComponent {
    componentContentChange?(): void;
    componentDataChange?(): void;
}
/**
 * TextBus 组件基类，不可直接继承 Component 类。
 * 如要扩展功能。请继承 DivisionAbstractComponent、BranchAbstractComponent、BackboneAbstractComponent 或 LeafAbstractComponent 类。
 */
export declare abstract class AbstractComponent extends Marker {
    tagName: string;
    [parentFragmentAccessToken]: Fragment | null;
    get parentFragment(): Fragment;
    /**
     * 在 TextBus 中，视所有模板为一个单独的个体，且规定长度为 1。
     */
    readonly length = 1;
    private canDispatchDataChange;
    private canDispatchContentChange;
    protected constructor(tagName: string);
    markAsDirtied(): void;
    markAsChanged(): void;
    /**
     * 克隆自己，返回一个完全一样的副本。
     */
    abstract clone(): AbstractComponent & ThisType<this>;
}
/**
 * 只有一个子插槽的组件，如 p、div、h1~h6、blockquote 等，也可以是用户自定义的只有一个子插槽的组件。
 * 需要注意的是，组件内部的结构是不可以通过用户编辑的。
 */
export declare abstract class DivisionAbstractComponent extends AbstractComponent {
    readonly slot: Fragment;
    protected constructor(tagName: string);
    /**
     * 用于把当前组件渲染成虚拟 DOM 树
     * @param isOutputMode  是否为输出模式。
     *                      当有些情况下，编辑模式和输出模式需要生成不一样的 DOM，且编辑模式可能需要监听一些事件，
     *                      以方便用户操作，这时可根据 isOutputMode 参数来作区分。
     * @param slotRendererFn 渲染插槽的工具函数
     */
    abstract render(isOutputMode: boolean, slotRendererFn: SlotRenderFn): VElement;
    abstract slotRender(isOutputMode: boolean, singleSlotRendererFn: SingleSlotRenderFn): VElement;
}
/**
 * 有任意个子插槽，且子插槽可以任意增删的组件。
 * 如 ul、ol 等，都保持一个固定的结构，但 li 的个数是不限制的，且是可以更改的。也可以用户自定义的组件。
 * 需要注意的是，组件内部的结构是不可以通过用户编辑的。
 */
export declare abstract class BranchAbstractComponent<T extends Fragment = Fragment> extends AbstractComponent {
    private eventMap;
    /**
     * 子插槽的集合
     */
    readonly slots: T[];
    abstract slotRender(slot: T, isOutputMode: boolean, slotRendererFn: SingleSlotRenderFn): VElement;
    /**
     * 用于把当前组件渲染成虚拟 DOM 树
     * @param isOutputMode  是否为输出模式。
     *                      当有些情况下，编辑模式和输出模式需要生成不一样的 DOM，且编辑模式可能需要监听一些事件，
     *                      以方便用户操作，这时可根据 isOutputMode 参数来作区分。
     * @param singleSlotRendererFn 渲染插槽的工具函数
     */
    abstract render(isOutputMode: boolean, singleSlotRendererFn: SlotRenderFn): VElement;
}
/**
 * 有任意个子插槽，且子插槽不可随意更改的组件。
 * 如 table，可以有多个 td，但 td 是不能随意删除的，否则会破坏 table 的结构。
 */
export declare abstract class BackboneAbstractComponent<T extends Fragment = Fragment> extends AbstractComponent implements Iterable<T> {
    get slotCount(): number;
    /**
     * 子插槽的集合
     */
    private eventMap;
    private slots;
    private iteratorIndex;
    /**
     * 当用户在文档中作框选删除时，由于 BackboneComponent 是不可编辑的，所以会导致 TextBus 无法判断当前组件是否为空组件，
     * 所以，在 TextBus 执行删除程序的过程中，如果遇到了 BackboneComponent，每清空一个 BackboneComponent 所属的 slot，
     * 就会询问，当前组件是否可以删除。
     * @param deletedSlot 当前清空的 fragment。
     */
    abstract canDelete(deletedSlot: T): boolean;
    [Symbol.iterator](): this;
    next(): {
        done: boolean;
        value: T;
    };
    getSlotAtIndex(index: number): T;
    indexOf(fragment: T): number;
    protected forEach(callbackFn: (value: T, index: number, array: T[]) => void, thisArg?: any): void;
    protected clean(): void;
    protected push(...fragments: T[]): void;
    protected pop(): T;
    protected splice(start: number, deleteCount?: number): T[];
    protected splice(start: number, deleteCount: number, ...items: T[]): T[];
    protected map<U>(callbackFn: (value: T, index: number, array: T[]) => U, thisArg?: any): U[];
    abstract slotRender(slot: T, isOutputMode: boolean, singleSlotRendererFn: SingleSlotRenderFn): VElement;
    /**
     * 用于把当前组件渲染成虚拟 DOM 树
     * @param isOutputMode  是否为输出模式。
     *                      当有些情况下，编辑模式和输出模式需要生成不一样的 DOM，且编辑模式可能需要监听一些事件，
     *                      以方便用户操作，这时可根据 isOutputMode 参数来作区分。
     * @param slotRendererFn 渲染插槽的工具函数
     */
    abstract render(isOutputMode: boolean, slotRendererFn: SlotRenderFn): VElement;
    private setup;
}
/**
 * 没有子插槽的组件，如 br、img等。也可以是用户自定义的组件。
 * 需要注意的是，组件内部的结构是不可以通过用户编辑的。
 */
export declare abstract class LeafAbstractComponent extends AbstractComponent {
    abstract get block(): boolean;
    protected constructor(tagName: string);
    /**
     * 用于把当前组件渲染成虚拟 DOM 树
     * @param isOutputMode  是否为输出模式。
     *                      当有些情况下，编辑模式和输出模式需要生成不一样的 DOM，且编辑模式可能需要监听一些事件，
     *                      以方便用户操作，这时可根据 isOutputMode 参数来作区分。
     */
    abstract render(isOutputMode: boolean): VElement;
}
export declare class BrComponent extends LeafAbstractComponent {
    block: boolean;
    constructor();
    clone(): BrComponent;
    render(): VElement;
}
