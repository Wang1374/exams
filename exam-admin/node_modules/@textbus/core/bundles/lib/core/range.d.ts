import { Type } from '@tanbo/di';
import { Renderer } from './renderer';
import { Fragment } from './fragment';
import { BranchAbstractComponent, DivisionAbstractComponent, AbstractComponent, BackboneAbstractComponent } from './component';
/**
 * 标识 Fragment 中的一个位置。
 */
export interface TBRangePosition {
    fragment: Fragment;
    index: number;
}
/**
 * 标识一个选中 Fragment 的范围。
 */
export interface TBRangeScope {
    startIndex: number;
    endIndex: number;
    fragment: Fragment;
}
export interface CommonAncestorFragmentScope {
    startIndex: number;
    startFragment: Fragment;
    startChildComponent: DivisionAbstractComponent | BranchAbstractComponent | BackboneAbstractComponent;
    endIndex: number;
    endFragment: Fragment;
    endChildComponent: DivisionAbstractComponent | BranchAbstractComponent | BackboneAbstractComponent;
    startChildFragment: Fragment;
    endChildFragment: Fragment;
}
export interface SlotRange<T extends BackboneAbstractComponent | BranchAbstractComponent> {
    component: T;
    startIndex: number;
    endIndex: number;
}
/**
 * TextBus 中的选区范围类，可操作基于 Fragment 和 Component 的范围，并提供了一系列的扩展方法供编辑富文本内容使用。
 */
export declare class TBRange {
    nativeRange: Range;
    private renderer;
    /** 选区范围开始位置 */
    startIndex: number;
    /** 选区范围结束位置 */
    endIndex: number;
    /** 开始选区范围 */
    startFragment: Fragment;
    /** 结束选区范围 */
    endFragment: Fragment;
    /**
     * 当前选区范围最近的公共 Fragment。
     */
    get commonAncestorFragment(): Fragment;
    /**
     * 当前选区范围最近的公共组件。
     */
    get commonAncestorComponent(): AbstractComponent;
    /**
     * 当前所选范围是否折叠。
     */
    get collapsed(): boolean;
    constructor(nativeRange: Range, renderer: Renderer);
    /**
     * 克隆一个完全一样的副本并返回。
     */
    clone(): TBRange;
    /**
     * 根据当前的 startFragment 和 startIndex，endFragment 和 endIndex，设置在浏览器的的选区范围。
     */
    restore(): this;
    /**
     * 设置选区范围开始的位置。
     * @param fragment 开始的片段
     * @param offset 开始的偏移位置，从 0 开始计算。
     */
    setStart(fragment: Fragment, offset: number): void;
    /**
     * 设置选区范围结束的位置。
     * @param fragment 结束的片段
     * @param offset 线束的偏移位置，从 0 开始计算。
     */
    setEnd(fragment: Fragment, offset: number): void;
    setPosition(fragment: Fragment, offset: number): void;
    /**
     * 获取当前选区在公共 Fragment 中的范围。
     */
    getCommonAncestorFragmentScope(): CommonAncestorFragmentScope;
    /**
     * 获取当前选区范围在 T 插槽的范围。
     * @param of 子类的构造 class。
     * @param filter 可选的过滤条件，可根据实例判断是否为想要找的 T 实例。
     */
    getSlotRange<T extends BranchAbstractComponent | BackboneAbstractComponent>(of: Type<T>, filter?: (instance: T) => boolean): SlotRange<T>[];
    /**
     * 获取当前选区选中的所有片段
     * 如（[]表示选区位置)：
     * <Fragment>
     *   <Inline>00[00</Inline>
     *   <ChildFragmentA>11111</ChildFragmentA>
     *   <ChildFragmentB>222]22</ChildFragmentB>
     * </Fragment>
     * 则返回：
     * [{
     *   fragment: Fragment,
     *   startIndex: 2,
     *   endIndex: 4,
     * }, {
     *   fragment: ChildFragmentA,
     *   startIndex: 0,
     *   endIndex: 5
     * }, {
     *   fragment: ChildFragmentB,
     *   startIndex: 0,
     *   endIndex: 3
     * }]
     */
    getSelectedScope(): TBRangeScope[];
    /**
     * 获取选区内扩展后的的 Inline
     * 如（[]表示选区位置)：
     * <Fragment>
     *   <Inline>00[00</Inline>
     *   <ChildFragmentA>11111</ChildFragmentA>
     *   <ChildFragmentB>222]22</ChildFragmentB>
     * </Fragment>
     * 则返回：
     * [{
     *   fragment: Fragment,
     *   startIndex: 0,
     *   endIndex: 4,
     * }, {
     *   fragment: ChildFragmentA,
     *   startIndex: 0,
     *   endIndex: 5
     * }, {
     *   fragment: ChildFragmentB,
     *   startIndex: 0,
     *   endIndex: 5
     * }]
     */
    getExpandedScope(): TBRangeScope[];
    /**
     * 获取选区内所有连续的 Inline
     * 如（[]表示选区位置)：
     * <Fragment>
     *   <Inline>00[00</Inline>
     *   <ChildFragmentA>11111</ChildFragmentA>
     *   <ChildFragmentB>222]22</ChildFragmentB>
     * </Fragment>
     * 则返回：
     * [{
     *   fragment: Fragment,
     *   startIndex: 0,
     *   endIndex: 4,
     * }, {
     *   fragment: ChildFragmentA,
     *   startIndex: 0,
     *   endIndex: 5
     * }, {
     *   fragment: ChildFragmentB,
     *   startIndex: 0,
     *   endIndex: 5
     * }]
     */
    getSuccessiveContents(): TBRangeScope[];
    delete(): void;
    /**
     * 删除选区范围内容，并合并选区范围。
     */
    deleteRange(): void;
    /**
     * 根据 Fragment 依次向上查找，如果 Fragment 为空或 Component 为空，则删除。
     * 直到根 Fragment 或当前 Fragment 等于 endFragment。
     * @param fragment 开始删除的 fragment。
     * @param endFragment 可选的结束的 fragment，如不传，则依次向上查找，直到根 fragment。
     * @return 删除内容后不为空的 component 或 fragment。
     */
    deleteEmptyTree(fragment: Fragment, endFragment?: Fragment): BranchAbstractComponent | BackboneAbstractComponent | Fragment;
    /**
     * 折叠当前选区
     * @param toEnd 是否折叠到结束位置
     */
    collapse(toEnd?: boolean): this;
    /**
     * 获取上一个选区位置。
     */
    getPreviousPosition(): TBRangePosition;
    /**
     * 获取下一个选区位置。
     */
    getNextPosition(): TBRangePosition;
    /**
     * 获取选区向上移动一行的位置。
     * @param startLeft 参考位置。
     */
    getPreviousLinePosition(startLeft: number): TBRangePosition;
    /**
     * 获取选区向下移动一行的位置。
     * @param startLeft 参考位置。
     */
    getNextLinePosition(startLeft: number): TBRangePosition;
    /**
     * 查找一个 fragment 下的第一个可以放置光标的位置。
     * @param fragment
     */
    findFirstPosition(fragment: Fragment): TBRangePosition;
    /**
     * 查找一个 fragment 下的最后一个可以放置光标的位置。
     * @param fragment
     */
    findLastPosition(fragment: Fragment): TBRangePosition;
    /**
     * 查找一个 fragment 下的最后一个可以放置光标的位置。
     * @param fragment
     */
    findLastChild(fragment: Fragment): TBRangePosition;
    /**
     * 获取选区范围在文档中的坐标位置。
     */
    getRangePosition(): DOMRect;
    /**
     * 删除选区范围内的内容。
     */
    private deleteSelectedScope;
    private getScopes;
    private getCommonAncestorFragment;
    private getCommonAncestorComponent;
    private findFocusNodeAndOffset;
    private static findExpandedStartIndex;
    private static findExpandedEndIndex;
    private static findPosition;
}
