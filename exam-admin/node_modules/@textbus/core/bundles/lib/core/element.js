var _a;
import { makeError } from '../_utils/make-error';
import { Subject } from 'rxjs';
const parentNode = Symbol('parentNode');
/**
 * 虚拟文本节点。
 */
export class VTextNode {
    constructor(textContent = '') {
        this.textContent = textContent;
    }
    get parentNode() {
        return this[parentNode];
    }
    clone() {
        return new VTextNode(this.textContent);
    }
}
const vElementErrorFn = makeError('VElement');
/**
 * 虚拟 DOM 节点
 */
export class VElement {
    constructor(tagName, options) {
        this.tagName = tagName;
        this[_a] = null;
        this.attrs = new Map();
        this.styles = new Map();
        this.classes = [];
        this._childNodes = [];
        this.unbindFns = [];
        this.destroyEvent = new Subject();
        this.onDestroy = this.destroyEvent.asObservable();
        if (options) {
            if (options.attrs) {
                Object.keys(options.attrs).forEach(key => {
                    const value = options.attrs[key];
                    if (value !== null && typeof value !== 'undefined') {
                        this.attrs.set(key, options.attrs[key]);
                    }
                });
            }
            if (options.styles) {
                Object.keys(options.styles).forEach(key => {
                    const value = options.styles[key];
                    if (value !== null && typeof value !== 'undefined') {
                        this.styles.set(key, options.styles[key]);
                    }
                });
            }
            if (options.classes) {
                this.classes.push(...options.classes);
            }
            if (options.childNodes) {
                this.appendChild(...options.childNodes);
            }
            this.listeners = options.on || {};
        }
    }
    static createElement(tagName, attrs, ...children) {
        if (typeof tagName === 'function') {
            return tagName(Object.assign(Object.assign({}, attrs), { children }));
        }
        attrs = attrs || {};
        const className = (attrs.class || '').trim();
        const classes = className ? className.split(/\s+/g) : [];
        Reflect.deleteProperty(attrs, 'class');
        const style = attrs.style || '';
        let styles;
        if (style && typeof style === 'string') {
            styles = {};
            style.split(';').map(s => s.split(':')).forEach(v => {
                if (!v[0] || !v[1]) {
                    return;
                }
                styles[v[0].trim()] = v[1].trim();
            });
        }
        else {
            styles = style;
        }
        Reflect.deleteProperty(attrs, 'style');
        const listeners = {};
        const attrs2 = {};
        Object.keys(attrs).forEach(key => {
            if (/^on[A-Z]/.test(key)) {
                listeners[key.replace(/^on/, '').toLowerCase()] = attrs[key];
            }
            else {
                attrs2[key] = attrs[key];
            }
        });
        const childNodes = [];
        const addChild = function (contents) {
            for (const c of contents) {
                if (c instanceof VElement) {
                    childNodes.push(c);
                }
                else if (typeof c === 'string' && c) {
                    childNodes.push(new VTextNode(c));
                }
                else if (Array.isArray(c)) {
                    addChild(c);
                }
                else if (c !== false) {
                    childNodes.push(new VTextNode(c + ''));
                }
            }
        };
        addChild(children);
        return new VElement(tagName, {
            styles,
            attrs: attrs2,
            classes,
            on: listeners,
            childNodes
        });
    }
    get parentNode() {
        return this[parentNode];
    }
    get childNodes() {
        return this._childNodes.map(i => i);
    }
    clone() {
        const attrs = {};
        const styles = {};
        this.attrs.forEach(((value, key) => {
            attrs[key] = value;
        }));
        this.styles.forEach((value, key) => {
            styles[key] = value;
        });
        return new VElement(this.tagName, {
            classes: [...this.classes],
            attrs,
            styles,
            childNodes: this._childNodes.map(i => i.clone())
        });
    }
    /**
     * 在最后位置添加一个子节点。
     * @param newNodes
     */
    appendChild(...newNodes) {
        newNodes.forEach(node => {
            var _b;
            (_b = node.parentNode) === null || _b === void 0 ? void 0 : _b.removeChild(node);
            node[parentNode] = this;
            this._childNodes.push(node);
        });
    }
    removeChild(node) {
        const index = this._childNodes.indexOf(node);
        if (index > -1) {
            this._childNodes.splice(index, 1);
            node[parentNode] = null;
            return;
        }
        throw vElementErrorFn('node to be deleted is not a child of the current node.');
    }
    replaceChild(newNode, oldNode) {
        var _b;
        const index = this._childNodes.indexOf(oldNode);
        if (index > -1) {
            (_b = newNode.parentNode) === null || _b === void 0 ? void 0 : _b.removeChild(newNode);
            this._childNodes.splice(index, 1, newNode);
            oldNode[parentNode] = null;
            newNode[parentNode] = this;
            return;
        }
        throw vElementErrorFn('node to be replaced is not a child of the current node.');
    }
    /**
     * 把当前虚拟 DOM 节点转换为 JSON 字面量。
     */
    toJSON() {
        return {
            tagName: this.tagName,
            styles: VElement.mapToJSON(this.styles),
            attrs: VElement.mapToJSON(this.attrs),
            classes: this.classes.map(i => i),
            childNodes: this._childNodes.map(c => {
                if (c instanceof VElement) {
                    return c.toJSON();
                }
                return c.textContent;
            })
        };
    }
    onRendered(nativeNode) {
        Object.keys(this.listeners || {}).forEach(listenKey => {
            const callback = this.listeners[listenKey];
            if (typeof callback === 'function') {
                nativeNode.addEventListener(listenKey, this.listeners[listenKey]);
                this.unbindFns.push(function () {
                    nativeNode.removeEventListener(listenKey, callback);
                });
            }
        });
    }
    destroy() {
        this.unbindFns.forEach(i => i());
        this.destroyEvent.next();
    }
    static mapToJSON(map) {
        const obj = {};
        map.forEach((value, key) => {
            obj[key] = value;
        });
        return obj;
    }
}
_a = parentNode;
//# sourceMappingURL=element.js.map