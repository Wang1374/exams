var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var RootComponent_1;
import { forwardRef, Inject, Injectable } from '@tanbo/di';
import { AbstractComponent, Component, DivisionAbstractComponent, Fragment, InlineFormatter, LeafAbstractComponent, Interceptor, TBSelection, VElement, BrComponent, } from './core/_api';
import { HackInput } from './_es-hack';
import { EditorController } from './editor-controller';
let RootComponentInterceptor = class RootComponentInterceptor {
    constructor(selection, input, rootComponent, editorController) {
        this.selection = selection;
        this.input = input;
        this.editorController = editorController;
        this.contentSnapshot = [];
        this.formatterSnapshot = new Map();
        this.rootComponent = rootComponent; // 为了解决提前引用的问题
    }
    onInputReady() {
        this.recordSnapshotFromEditingBefore();
    }
    onInput() {
        const selection = this.selection;
        const startIndex = this.selectionSnapshot.firstRange.startIndex;
        const latestFragment = new Fragment();
        const contentSnapshot = this.contentSnapshot;
        contentSnapshot.forEach(i => latestFragment.append(i));
        this.mergeFormats(latestFragment);
        const input = this.input;
        let index = 0;
        input.value.replace(/\n+|[^\n]+/g, (str) => {
            if (/\n+/.test(str)) {
                for (let i = 0; i < str.length; i++) {
                    const s = new BrComponent();
                    latestFragment.insert(s, index + startIndex);
                    index++;
                }
            }
            else {
                latestFragment.insert(str, startIndex + index);
                index += str.length;
            }
            return str;
        });
        const isEmptyFragment = contentSnapshot.length === 1 && contentSnapshot[0] instanceof BrComponent;
        if (isEmptyFragment && latestFragment.length > 1) {
            latestFragment.remove(latestFragment.length - 1);
        }
        selection.firstRange.startIndex = selection.firstRange.endIndex = startIndex + input.selectionStart;
        const last = latestFragment.getContentAtIndex(latestFragment.length - 1);
        if (startIndex + input.selectionStart === latestFragment.length &&
            last instanceof BrComponent) {
            latestFragment.append(new BrComponent(), true);
        }
        selection.commonAncestorFragment.from(latestFragment);
    }
    onEnter() {
        const firstRange = this.selection.firstRange;
        const rootFragment = firstRange.startFragment;
        rootFragment.insert(new BrComponent(), firstRange.startIndex);
        firstRange.startIndex = firstRange.endIndex = firstRange.startIndex + 1;
        const afterContent = rootFragment.getContentAtIndex(firstRange.startIndex);
        if (typeof afterContent === 'string') {
            return;
        }
        if (firstRange.startIndex === rootFragment.length ||
            afterContent instanceof LeafAbstractComponent && afterContent.block ||
            afterContent instanceof AbstractComponent && !(afterContent instanceof LeafAbstractComponent)) {
            rootFragment.insert(new BrComponent(), firstRange.startIndex);
        }
    }
    onPaste(event) {
        const firstRange = this.selection.firstRange;
        const clipboardFragment = event.data.fragment;
        const fragment = firstRange.startFragment;
        const contents = clipboardFragment.sliceContents();
        const isEmpty = fragment.length === 0 || fragment.length === 1 && fragment.getContentAtIndex(0) instanceof BrComponent;
        const hasBlockComponent = contents.map(i => {
            return i instanceof AbstractComponent && !(i instanceof LeafAbstractComponent);
        }).includes(true);
        if (!hasBlockComponent) {
            const len = clipboardFragment.length;
            const formats = [];
            if (isEmpty && firstRange.startIndex === 0) {
                fragment.getFormatKeys().forEach(key => {
                    formats.push(...fragment.getFormatRanges(key));
                });
            }
            fragment.insert(clipboardFragment, firstRange.startIndex);
            formats.forEach(f => f.startIndex = 0);
            firstRange.startIndex = firstRange.endIndex = firstRange.startIndex + len;
            return;
        }
        const firstContent = clipboardFragment.getContentAtIndex(0);
        const isSingleComponent = clipboardFragment.length === 1 &&
            firstContent instanceof AbstractComponent &&
            !(firstContent instanceof LeafAbstractComponent);
        const parentComponent = fragment.parentComponent;
        const parentFragment = parentComponent.parentFragment;
        if (!parentFragment) {
            fragment.insert(clipboardFragment, firstRange.startIndex);
            return;
        }
        const index = parentFragment.indexOf(parentComponent);
        if (isEmpty && isSingleComponent) {
            parentFragment.insert(firstContent, index);
            return;
        }
        const contentLength = fragment.length;
        if (isSingleComponent &&
            (firstRange.endIndex === contentLength || firstRange.endIndex === contentLength - 1 && fragment.getContentAtIndex(contentLength - 1) instanceof BrComponent)) {
            parentFragment.insertAfter(firstContent, parentComponent);
            return;
        }
        const isAllBlock = !contents.map(i => {
            return i instanceof AbstractComponent && !(i instanceof LeafAbstractComponent);
        }).includes(false);
        if (isAllBlock && isEmpty) {
            contents.reverse().forEach(c => {
                parentFragment.insert(c, index);
            });
            return;
        }
        const len = clipboardFragment.length;
        fragment.insert(clipboardFragment, firstRange.startIndex);
        firstRange.startIndex = firstRange.endIndex = firstRange.startIndex + len;
    }
    onDeleteRange() {
        this.selection.ranges.forEach(range => {
            range.deleteRange();
        });
    }
    onDelete() {
        this.selection.ranges.forEach(range => {
            range.delete();
        });
    }
    mergeFormats(latestFragment) {
        this.formatterSnapshot.forEach((formatRanges, key) => {
            if (key instanceof InlineFormatter) {
                formatRanges.forEach(formatRange => {
                    var _a;
                    latestFragment.apply(key, Object.assign(Object.assign({}, formatRange), { formatData: (_a = formatRange.formatData) === null || _a === void 0 ? void 0 : _a.clone() }));
                });
            }
            else {
                formatRanges.forEach(formatRange => {
                    var _a;
                    latestFragment.apply(key, {
                        get startIndex() {
                            return 0;
                        },
                        get endIndex() {
                            return latestFragment.length;
                        },
                        effect: formatRange.effect,
                        formatData: (_a = formatRange.formatData) === null || _a === void 0 ? void 0 : _a.clone()
                    });
                });
            }
        });
    }
    recordSnapshotFromEditingBefore() {
        this.selectionSnapshot = this.selection.clone();
        const commonAncestorFragment = this.selectionSnapshot.commonAncestorFragment;
        this.contentSnapshot = commonAncestorFragment.sliceContents();
        this.formatterSnapshot.clear();
        commonAncestorFragment.getFormatKeys().forEach(token => {
            this.formatterSnapshot.set(token, commonAncestorFragment.getFormatRanges(token).map(formatRange => {
                var _a, _b;
                if (token instanceof InlineFormatter) {
                    return Object.assign(Object.assign({}, formatRange), { formatData: (_a = formatRange.formatData) === null || _a === void 0 ? void 0 : _a.clone() });
                }
                return {
                    startIndex: 0,
                    endIndex: formatRange.endIndex,
                    effect: formatRange.effect,
                    formatData: (_b = formatRange.formatData) === null || _b === void 0 ? void 0 : _b.clone()
                };
            }));
        });
    }
};
RootComponentInterceptor = __decorate([
    Injectable(),
    __param(0, Inject(forwardRef(() => TBSelection))),
    __param(1, Inject(forwardRef(() => HackInput))),
    __param(2, Inject(forwardRef(() => RootComponent))),
    __param(3, Inject(forwardRef(() => EditorController))),
    __metadata("design:paramtypes", [TBSelection,
        HackInput, Object, EditorController])
], RootComponentInterceptor);
class RootComponentLoader {
    match() {
        return false;
    }
    read(node) {
        const component = new RootComponent();
        return {
            component,
            slotsMap: [{
                    toSlot: component.slot,
                    from: node
                }]
        };
    }
}
let RootComponent = RootComponent_1 = class RootComponent extends DivisionAbstractComponent {
    constructor() {
        super('body');
    }
    clone() {
        const component = new RootComponent_1();
        component.slot.from(this.slot.clone());
        return component;
    }
    slotRender(isOutputMode, slotRenderFn) {
        return slotRenderFn(this.slot, new VElement(this.tagName));
    }
    render(isOutputMode, renderFn) {
        return renderFn(this.slot);
    }
};
RootComponent = RootComponent_1 = __decorate([
    Component({
        loader: new RootComponentLoader(),
        providers: [{
                provide: Interceptor,
                useClass: RootComponentInterceptor
            }],
        styles: [
            `body{word-break: break-word;}`
        ]
    }),
    Injectable(),
    __metadata("design:paramtypes", [])
], RootComponent);
export { RootComponent };
//# sourceMappingURL=root-component.js.map