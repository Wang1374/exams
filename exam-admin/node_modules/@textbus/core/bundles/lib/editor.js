import { from, fromEvent, Observable, of, Subject } from 'rxjs';
import { debounceTime } from 'rxjs/operators';
import { getAnnotations, InjectFlags, Injector, NullInjector, ReflectiveInjector, } from '@tanbo/di';
import { AbstractComponent, BackboneAbstractComponent, BranchAbstractComponent, BrComponent, Component, DivisionAbstractComponent, LeafAbstractComponent, MarkdownSupport, OutputRenderer, Parser, Renderer, TBRange, TBSelection } from './core/_api';
import { FileUploader, Input, Layout, UIControlPanel, UIDialog, UIMessage } from './ui/_api';
import { HTMLOutputTranslator, OutputTranslator } from './output-translator';
import { EditorController } from './editor-controller';
import { makeError } from './_utils/make-error';
import { ComponentInjectors } from './component-injectors';
import { EDITABLE_DOCUMENT, EDITOR_OPTIONS } from './inject-tokens';
import { RootComponent } from './root-component';
import { TBHistory } from './history';
import { I18n, i18n_zh_CN } from './i18n/_api';
import { HackInput } from './_es-hack';
const editorErrorFn = makeError('Editor');
/**
 * TextBus 主类
 */
export class Editor {
    constructor(selector, options = {}) {
        this.selector = selector;
        this.options = options;
        /** 组件状态控制器 */
        this.stateController = null;
        /** 编辑器注入器，在编辑准备完成时可用 */
        this.injector = null;
        this.defaultPlugins = [
            UIDialog,
            UIControlPanel,
            UIMessage,
        ];
        this.readyState = false;
        this.tasks = [];
        this.readyEvent = new Subject();
        this.subs = [];
        this.changeEvent = new Subject();
        if (typeof selector === 'string') {
            this.container = document.querySelector(selector);
        }
        else {
            this.container = selector;
        }
        if (!this.container || !(this.container instanceof HTMLElement)) {
            throw editorErrorFn('selector is not an HTMLElement, or the CSS selector cannot find a DOM element in the document.');
        }
        this.onReady = this.readyEvent.asObservable();
        this.onChange = this.changeEvent.asObservable();
        this.stateController = new EditorController({
            readonly: false,
            sourcecodeMode: false,
            supportMarkdown: true
        });
        const i18n = new I18n(i18n_zh_CN, options.i18n);
        const rootInjector = new ReflectiveInjector(new NullInjector(), [Layout, {
                provide: EditorController,
                useValue: this.stateController
            }, {
                provide: I18n,
                useValue: i18n
            }]);
        const layout = rootInjector.get(Layout);
        layout.setTheme(options.theme);
        this.layout = layout;
        this.subs.push(layout.onReady.subscribe(contentDocument => {
            const injector = this.bootstrap(rootInjector, contentDocument);
            this.init(injector);
        }));
        this.container.appendChild(layout.container);
    }
    set readonly(b) {
        this.stateController.readonly = b;
    }
    get readonly() {
        return this.stateController.readonly;
    }
    set supportMarkdown(b) {
        this.stateController.supportMarkdown = b;
    }
    get supportMarkdown() {
        return this.stateController.supportMarkdown;
    }
    /**
     * 设置 TextBus 编辑器的内容。
     * @param html
     */
    setContents(html) {
        return new Promise((resolve) => {
            this.run(() => {
                const parser = this.injector.get(Parser);
                const fragment = parser.parse(Parser.parserHTML(html));
                this.injector.get(RootComponent).slot.from(fragment);
                setTimeout(() => {
                    const layout = this.injector.get(Layout);
                    layout.scroller.scrollTop = 0;
                    this.updateDocHeight(layout.iframe, layout.workbench, this.injector.get(EDITABLE_DOCUMENT));
                    resolve();
                }, 30);
            });
        });
    }
    /**
     * 获取 TextBus 的内容。
     */
    getContents() {
        const metadata = this.getOutputComponentMetadata();
        const outputTranslator = this.injector.get(OutputTranslator);
        const outputRenderer = this.injector.get(OutputRenderer);
        const rootComponent = this.injector.get(RootComponent);
        const content = outputTranslator.transform(outputRenderer.render(rootComponent));
        return {
            content,
            links: metadata.links,
            styleSheets: metadata.styles,
            scripts: metadata.scripts
        };
    }
    /**
     * 获取 TextBus 内容的 JSON 字面量。
     */
    getJSONLiteral() {
        const outputRenderer = this.injector.get(OutputRenderer);
        const rootComponent = this.injector.get(RootComponent);
        const json = outputRenderer.render(rootComponent).toJSON();
        const metadata = this.getOutputComponentMetadata();
        return {
            content: json,
            links: metadata.links,
            styleSheets: metadata.styles,
            scripts: metadata.scripts
        };
    }
    /**
     * 销毁 TextBus 实例。
     */
    destroy() {
        this.subs.forEach(s => s.unsubscribe());
        [Input, Layout, ComponentInjectors].forEach(i => {
            this.injector.get(i).destroy();
        });
        [...(this.defaultPlugins), ...(this.options.plugins || [])].forEach(p => {
            var _a, _b;
            (_b = (_a = this.injector.get(p)).onDestroy) === null || _b === void 0 ? void 0 : _b.call(_a);
        });
        this.container.removeChild(this.layout.container);
    }
    getOutputComponentMetadata() {
        const classes = this.getReferencedComponents();
        const styles = [...(this.options.styleSheets || '')];
        const scripts = [];
        const links = [];
        classes.forEach(c => {
            const annotation = getAnnotations(c).getClassMetadata(Component).metadata;
            if (annotation.styles) {
                styles.push(...annotation.styles.filter(i => i));
            }
            if (annotation.scripts) {
                scripts.push(...annotation.scripts.filter(i => i));
            }
            if (annotation.links) {
                links.push(...annotation.links);
            }
        });
        return {
            links,
            styles: Array.from(new Set(styles)).map(i => Editor.cssMin(i)),
            scripts: Array.from(new Set(scripts))
        };
    }
    getReferencedComponents() {
        function getComponentCollection(component) {
            const collection = [component];
            const fragments = [];
            if (component instanceof DivisionAbstractComponent) {
                fragments.push(component.slot);
            }
            else if (component instanceof BranchAbstractComponent) {
                fragments.push(...component.slots);
            }
            else if (component instanceof BackboneAbstractComponent) {
                fragments.push(...Array.from(component));
            }
            fragments.forEach(fragment => {
                fragment.sliceContents().forEach(i => {
                    if (i instanceof AbstractComponent) {
                        collection.push(...getComponentCollection(i));
                    }
                });
            });
            return collection;
        }
        const instances = getComponentCollection(this.injector.get(RootComponent));
        return Array.from(new Set(instances.map(i => i.constructor)));
    }
    init(injector) {
        this.injector = injector;
        const contentDocument = injector.get(EDITABLE_DOCUMENT);
        const layout = injector.get(Layout);
        const rootComponent = injector.get(RootComponent);
        const selection = injector.get(TBSelection);
        const renderer = injector.get(Renderer);
        const parser = injector.get(Parser);
        this.subs.push(rootComponent.onChange.pipe(debounceTime(1)).subscribe(() => {
            renderer.render(rootComponent);
            Promise.resolve().then(() => selection.restore());
        }), fromEvent(contentDocument, 'click').subscribe((ev) => {
            const sourceElement = ev.target;
            const focusNode = this.findFocusNode(sourceElement, renderer);
            if (!focusNode || focusNode === sourceElement) {
                return;
            }
            const position = renderer.getPositionByNode(focusNode);
            if (position.endIndex - position.startIndex === 1) {
                const content = position.fragment.getContentAtIndex(position.startIndex);
                if (content instanceof LeafAbstractComponent) {
                    if (!selection.firstRange) {
                        const range = new TBRange(contentDocument.createRange(), renderer);
                        selection.addRange(range);
                    }
                    selection.firstRange.setStart(position.fragment, position.endIndex);
                    selection.firstRange.collapse();
                    selection.restore();
                }
            }
        }), renderer.onViewUpdated.subscribe(() => {
            this.changeEvent.next();
        }));
        const dom = Parser.parserHTML(this.options.contents || '<p><br></p>');
        rootComponent.slot.from(parser.parse(dom));
        this.listen(layout.iframe, layout.workbench, contentDocument);
        this.defaultPlugins.forEach(f => {
            injector.get(f).setup();
        });
        const input = injector.get(Input);
        if (typeof this.options.onSave === 'function') {
            input.addKeymap({
                keymap: {
                    ctrlKey: true,
                    key: 's'
                },
                action: () => {
                    this.options.onSave();
                }
            });
        }
        injector.get(TBHistory).record();
        const customPlugins = this.options.plugins || [];
        let i = 0;
        if (!customPlugins.length) {
            this.readyState = true;
            this.readyEvent.next();
            this.tasks.forEach(fn => fn());
        }
        else {
            customPlugins.forEach(f => {
                setTimeout(() => {
                    i++;
                    injector.get(f).setup();
                    if (i === customPlugins.length) {
                        this.readyState = true;
                        this.readyEvent.next();
                        this.tasks.forEach(fn => fn());
                    }
                });
            });
        }
    }
    bootstrap(rootInjector, contentDocument) {
        const renderer = new Renderer(contentDocument.body);
        const selection = new TBSelection(contentDocument, fromEvent(contentDocument, 'selectionchange'), renderer);
        this.componentAnnotations = [RootComponent, ...(this.options.components || []), BrComponent].map(c => {
            return getAnnotations(c).getClassMetadata(Component).metadata;
        });
        this.setDocStyle(this.componentAnnotations, contentDocument);
        const parser = new Parser(this.componentAnnotations.map(c => c.loader), this.options.formatters);
        const componentInjectors = new ComponentInjectors();
        const editorInjector = new ReflectiveInjector(rootInjector, [
            ...this.defaultPlugins,
            Input,
            TBHistory,
            RootComponent, {
                provide: HackInput,
                useClass: Input
            }, {
                provide: EDITABLE_DOCUMENT,
                useValue: contentDocument
            }, {
                provide: EDITOR_OPTIONS,
                useValue: this.options
            }, {
                provide: Editor,
                useValue: this
            }, {
                provide: OutputRenderer,
                useValue: new OutputRenderer()
            }, {
                provide: OutputTranslator,
                useValue: new HTMLOutputTranslator()
            }, {
                provide: Parser,
                useValue: parser
            }, {
                provide: TBSelection,
                useValue: selection
            }, {
                provide: Renderer,
                useValue: renderer
            }, {
                provide: ComponentInjectors,
                useValue: componentInjectors
            }, {
                provide: FileUploader,
                useFactory: (message, i18n, selection, rootComponent) => {
                    return {
                        upload: (type, currentValue) => {
                            if (selection.rangeCount === 0) {
                                const range = selection.createRange();
                                const position = range.findLastPosition(rootComponent.slot);
                                range.setPosition(position.fragment, position.index);
                                selection.addRange(range);
                            }
                            if (typeof this.options.uploader === 'function') {
                                const result = this.options.uploader(type, currentValue);
                                if (result instanceof Observable) {
                                    return result;
                                }
                                else if (result instanceof Promise) {
                                    return from(result);
                                }
                                else if (typeof result === 'string') {
                                    return of(result);
                                }
                            }
                            message.message(i18n.get('editor.noUploader'));
                            return of('');
                        }
                    };
                },
                deps: [UIMessage, I18n, TBSelection, RootComponent]
            }
        ]);
        const customInjector = new ReflectiveInjector(editorInjector, [
            ...(this.options.providers || []),
            ...(this.options.plugins || []), {
                provide: Injector,
                useFactory() {
                    return customInjector;
                }
            }
        ]);
        const input = customInjector.get(Input);
        [RootComponent, ...(this.options.components || [])].forEach(c => {
            const metadata = getAnnotations(c).getClassMetadata(Component);
            const annotation = metadata.metadata;
            const componentInjector = new ReflectiveInjector(customInjector, annotation.providers || []);
            componentInjectors.set(c, componentInjector);
            const markdownSupport = componentInjector.get(MarkdownSupport, null, InjectFlags.Optional);
            if (markdownSupport) {
                const markdownGrammarInterceptor = markdownSupport.provide();
                input.addMarkdownSupport(markdownGrammarInterceptor);
            }
        });
        return customInjector;
    }
    setDocStyle(componentAnnotations, contentDocument) {
        const links = [];
        const componentStyles = componentAnnotations.map(c => {
            var _a, _b;
            if (Array.isArray(c.links)) {
                links.push(...c.links);
            }
            return [((_a = c.styles) === null || _a === void 0 ? void 0 : _a.join('')) || '', ((_b = c.editModeStyles) === null || _b === void 0 ? void 0 : _b.join('')) || ''].join('');
        }).join('');
        links.forEach(link => {
            const linkEle = contentDocument.createElement('link');
            Object.assign(linkEle, link);
            contentDocument.head.appendChild(linkEle);
        });
        const docStyles = Editor.cssMin([componentStyles, ...(this.options.styleSheets || [])].join(''));
        const styleEl = contentDocument.createElement('style');
        styleEl.innerHTML = Editor.cssMin([...docStyles, ...(this.options.editingStyleSheets || [])].join(''));
        contentDocument.head.append(styleEl);
    }
    run(fn) {
        if (!this.readyState) {
            this.tasks.push(fn);
            return;
        }
        fn();
    }
    listen(iframe, container, contentDocument) {
        if (!(contentDocument === null || contentDocument === void 0 ? void 0 : contentDocument.body)) {
            return;
        }
        this.resizeObserver = new ResizeObserver(() => {
            this.updateDocHeight(iframe, container, contentDocument);
        });
        this.resizeObserver.observe(contentDocument.body);
    }
    updateDocHeight(iframe, container, contentDocument) {
        const childBody = contentDocument.body;
        const lastChild = childBody.lastChild;
        let height = 0;
        if (lastChild) {
            if (lastChild.nodeType === Node.ELEMENT_NODE) {
                height = lastChild.getBoundingClientRect().bottom;
            }
            else {
                const div = contentDocument.createElement('div');
                childBody.appendChild(div);
                height = div.getBoundingClientRect().bottom;
                childBody.removeChild(div);
            }
        }
        iframe.style.height = Math.max(height, container.offsetHeight) + 'px';
    }
    findFocusNode(node, renderer) {
        const position = renderer.getPositionByNode(node);
        if (!position) {
            const parentNode = node.parentNode;
            if (parentNode) {
                return this.findFocusNode(parentNode, renderer);
            }
            return null;
        }
        return node;
    }
    static cssMin(str) {
        return str
            .replace(/\s*(?=[>{}:;,[])/g, '')
            .replace(/([>{}:;,])\s*/g, '$1')
            .replace(/;}/g, '}').replace(/\s+/, ' ').trim();
    }
}
//# sourceMappingURL=editor.js.map