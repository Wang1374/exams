import { InlineFormatter, FormatEffect, VElement, FormatterPriority } from '@textbus/core';
export class StyleFormatter extends InlineFormatter {
    constructor(styleName, rule) {
        super(rule, FormatterPriority.InlineStyle);
        this.styleName = styleName;
    }
    read(node) {
        return this.extractData(node, {
            styleName: this.styleName
        });
    }
    render(context, existingElement) {
        if (existingElement) {
            existingElement.styles.set(this.styleName, context.formatData.styles.get(this.styleName));
        }
        else {
            const el = new VElement('span');
            el.styles.set(this.styleName, context.formatData.styles.get(this.styleName));
            return el;
        }
    }
}
export const colorFormatter = new StyleFormatter('color', {
    styles: {
        color: /.+/
    }
});
export const fontSizeFormatter = new StyleFormatter('fontSize', {
    styles: {
        fontSize: /.+/
    }
});
export const letterSpacingFormatter = new StyleFormatter('letterSpacing', {
    styles: {
        letterSpacing: /.+/
    }
});
export const fontFamilyFormatter = new StyleFormatter('fontFamily', {
    styles: {
        fontFamily: /.+/
    }
});
export const lineHeightFormatter = new StyleFormatter('lineHeight', {
    styles: {
        lineHeight: /.+/
    }
});
export class InlineBackgroundColorFormatter extends StyleFormatter {
    constructor() {
        super('backgroundColor', {
            styles: {
                backgroundColor: /.+/
            }
        });
        this.reg = new RegExp(`^(${InlineBackgroundColorFormatter.inlineTags.join('|')})$`, 'i');
    }
    match(p) {
        if (!this.reg.test(p.tagName)) {
            return FormatEffect.Invalid;
        }
        return super.match(p);
    }
    render(context, existingElement) {
        if (existingElement && this.reg.test(existingElement.tagName)) {
            existingElement.styles.set(this.styleName, context.formatData.styles.get(this.styleName));
        }
        else {
            const el = new VElement('span');
            el.styles.set(this.styleName, context.formatData.styles.get(this.styleName));
            return el;
        }
    }
}
InlineBackgroundColorFormatter.inlineTags = 'span,em,i,s,del,sup,sub,u,strong'.split(',');
export const backgroundColorFormatter = new InlineBackgroundColorFormatter();
//# sourceMappingURL=style.formatter.js.map