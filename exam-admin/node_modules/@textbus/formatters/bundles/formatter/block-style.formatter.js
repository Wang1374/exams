import { FormatEffect, BlockFormatter, FormatData, VElement, FormatterPriority } from '@textbus/core';
import { parseCss, rgb2Hex } from '@tanbo/color';
export class BlockStyleFormatter extends BlockFormatter {
    constructor(styleName, rule) {
        super(rule, FormatterPriority.BlockStyle);
        this.styleName = styleName;
    }
    read(node) {
        return this.extractData(node, {
            styleName: this.styleName
        });
    }
    render(context, existingElement) {
        existingElement = existingElement || new VElement('div');
        (Array.isArray(this.styleName) ? this.styleName : [this.styleName]).forEach(name => {
            existingElement.styles.set(name, context.formatData.styles.get(name));
        });
        return existingElement;
    }
}
export const textIndentFormatter = new BlockStyleFormatter('textIndent', {
    styles: {
        textIndent: /.+/
    }
});
export const textAlignFormatter = new BlockStyleFormatter('textAlign', {
    styles: {
        textAlign: /.+/
    }
});
export class BlockBackgroundColorFormatter extends BlockStyleFormatter {
    read(node) {
        return new FormatData({
            styles: {
                backgroundColor: (color => {
                    if (/^rgb\b/.test(color)) {
                        return rgb2Hex(parseCss(color));
                    }
                })(node.style.backgroundColor)
            }
        });
    }
    match(p) {
        const reg = new RegExp(`^(${BlockBackgroundColorFormatter.blockTags.join('|')})$`, 'i');
        if (!reg.test(p.tagName)) {
            return FormatEffect.Invalid;
        }
        return super.match(p);
    }
}
BlockBackgroundColorFormatter.blockTags = 'div,p,h1,h2,h3,h4,h5,h6,nav,header,footer,td,th,li,article'.split(',');
export const blockBackgroundColorFormatter = new BlockBackgroundColorFormatter('backgroundColor', {
    styles: {
        backgroundColor: /.+/
    }
});
//# sourceMappingURL=block-style.formatter.js.map