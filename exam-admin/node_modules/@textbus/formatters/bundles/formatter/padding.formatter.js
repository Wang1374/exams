import { BlockFormatter, FormatEffect, FormatterPriority, InlineFormatter, VElement } from '@textbus/core';
function match(reg, p) {
    if (!reg.test(p.tagName)) {
        return FormatEffect.Invalid;
    }
    const styleKeys = ['padding', 'paddingLeft', 'paddingRight', 'paddingTop', 'paddingBottom'];
    return styleKeys.map(key => p.style[key]).filter(i => !!i).length > 0 ? FormatEffect.Valid : FormatEffect.Invalid;
}
function render(reg, context, existingElement) {
    const padding = [
        context.formatData.styles.get('paddingTop'),
        context.formatData.styles.get('paddingRight'),
        context.formatData.styles.get('paddingBottom'),
        context.formatData.styles.get('paddingLeft'),
    ].map(i => i || 0);
    if (existingElement && reg.test(existingElement.tagName)) {
        existingElement.styles.set('padding', padding.join(' '));
        return null;
    }
    existingElement = new VElement('span');
    existingElement.styles.set('padding', padding.join(' '));
    return existingElement;
}
export class InlinePaddingFormatter extends InlineFormatter {
    constructor() {
        super({}, FormatterPriority.InlineStyle);
        this.reg = new RegExp(`^(${InlinePaddingFormatter.inlineTags.join('|')})$`, 'i');
    }
    match(p) {
        return match(this.reg, p);
    }
    read(node) {
        return this.extractData(node, {
            styleName: ['paddingLeft', 'paddingRight', 'paddingTop', 'paddingBottom']
        });
    }
    render(context, existingElement) {
        return render(this.reg, context, existingElement);
    }
}
InlinePaddingFormatter.inlineTags = 'span,em,i,s,del,sup,sub,u,strong'.split(',');
export class BlockPaddingFormatter extends BlockFormatter {
    constructor() {
        super({}, FormatterPriority.InlineStyle);
        this.reg = new RegExp(`^(${BlockPaddingFormatter.blockTags.join('|')})$`, 'i');
    }
    match(p) {
        return match(this.reg, p);
    }
    read(node) {
        return this.extractData(node, {
            styleName: ['paddingLeft', 'paddingRight', 'paddingTop', 'paddingBottom']
        });
    }
    render(context, existingElement) {
        return render(this.reg, context, existingElement);
    }
}
BlockPaddingFormatter.blockTags = 'div,p,h1,h2,h3,h4,h5,h6,nav,header,footer,td,th,li,article'.split(',');
export const inlinePaddingFormatter = new InlinePaddingFormatter();
export const blockPaddingFormatter = new BlockPaddingFormatter();
//# sourceMappingURL=padding.formatter.js.map