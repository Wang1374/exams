var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "./injector", "./metadata", "./decorators", "./utils/stringify", "./injectable", "./injection-token"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.normalizeProvider = void 0;
    var injector_1 = require("./injector");
    var metadata_1 = require("./metadata");
    var decorators_1 = require("./decorators");
    var stringify_1 = require("./utils/stringify");
    var injectable_1 = require("./injectable");
    var injection_token_1 = require("./injection-token");
    /**
     * 标准化 provide，并返回统一数据结构
     * @param provider
     */
    function normalizeProvider(provider) {
        if (provider.useValue) {
            return normalizeValueProviderFactory(provider);
        }
        if (provider.useClass) {
            return normalizeClassProviderFactory(provider);
        }
        if (provider.useExisting) {
            return normalizeExistingProviderFactory(provider);
        }
        if (provider.useFactory) {
            return normalizeFactoryProviderFactory(provider);
        }
        if (provider.provide) {
            if (provider.provide instanceof injection_token_1.InjectionToken) {
                return normalizeValueProviderFactory(provider);
            }
            return normalizeConstructorProviderFactory(provider);
        }
        return normalizeTypeProviderFactory(provider);
    }
    exports.normalizeProvider = normalizeProvider;
    function normalizeValueProviderFactory(provider) {
        return {
            provide: provider.provide,
            scope: null,
            generateFactory: function () {
                return function () {
                    return provider.useValue;
                };
            },
            deps: []
        };
    }
    function normalizeClassProviderFactory(provider) {
        var deps;
        var provideIn;
        if (provider.deps) {
            deps = normalizeDeps(provider.provide, provider.deps);
        }
        else {
            var resolvedClass = resolveClassParams(provider.useClass);
            provideIn = resolvedClass.scope;
            deps = normalizeDeps(provider.provide, resolvedClass.deps);
        }
        return {
            provide: provider.provide,
            scope: provideIn,
            deps: deps,
            generateFactory: function (injector, cacheFn) {
                return function () {
                    var _a;
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i];
                    }
                    if (provider.provide !== provider.useClass) {
                        var cachedInstance = injector.get(provider.useClass, null, injector_1.InjectFlags.Optional);
                        if (cachedInstance) {
                            return cachedInstance;
                        }
                    }
                    var instance = new ((_a = provider.useClass).bind.apply(_a, __spread([void 0], args)))();
                    var propMetadataKeys = decorators_1.getAnnotations(provider.useClass).getPropMetadataKeys();
                    propMetadataKeys.forEach(function (key) {
                        var propsMetadata = decorators_1.getAnnotations(provider.useClass).getPropMetadata(key) || [];
                        propsMetadata.forEach(function (item) {
                            item.contextCallback(instance, item.propertyKey, injector);
                        });
                    });
                    cacheFn(provider.provide, instance);
                    if (provider.provide !== provider.useClass) {
                        cacheFn(provider.useClass, instance);
                    }
                    return instance;
                };
            }
        };
    }
    function normalizeExistingProviderFactory(provider) {
        return {
            provide: provider.provide,
            scope: null,
            generateFactory: function (injector) {
                return function () {
                    return injector.get(provider.useExisting);
                };
            },
            deps: []
        };
    }
    function normalizeFactoryProviderFactory(provider) {
        return {
            provide: provider.provide,
            scope: null,
            generateFactory: function () {
                return function () {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i];
                    }
                    return provider.useFactory.apply(provider, __spread(args));
                };
            },
            deps: normalizeDeps(provider.provide, provider.deps || [])
        };
    }
    function normalizeConstructorProviderFactory(provider) {
        return normalizeClassProviderFactory(__assign(__assign({}, provider), { useClass: provider.provide }));
    }
    function normalizeTypeProviderFactory(provider) {
        return normalizeClassProviderFactory({
            provide: provider,
            useClass: provider
        });
    }
    function resolveClassParams(construct) {
        var annotations = decorators_1.getAnnotations(construct);
        var metadata = annotations.getClassMetadata(injectable_1.Injectable);
        if (typeof metadata === 'undefined') {
            throw new Error("Class `" + stringify_1.stringify(construct) + "` is not injectable!");
        }
        var deps = (metadata.paramTypes || []).map(function (i) { return [i]; });
        var metadataKeys = [metadata_1.Inject, metadata_1.Self, metadata_1.SkipSelf, metadata_1.Optional];
        metadataKeys.forEach(function (key) {
            (annotations.getParamMetadata(key) || []).forEach(function (item) {
                deps[item.parameterIndex].push(item.metadata);
            });
        });
        return {
            scope: metadata.metadata.provideIn,
            deps: deps
        };
    }
    function normalizeDeps(provide, deps) {
        return deps.map(function (dep, index) {
            var r = {
                injectKey: null,
                optional: false,
                visibility: null
            };
            if (!Array.isArray(dep)) {
                r.injectKey = dep;
            }
            else {
                for (var i = 0; i < dep.length; i++) {
                    var item = dep[i];
                    if (item instanceof metadata_1.Inject) {
                        r.injectKey = item.token;
                    }
                    else if (item instanceof metadata_1.Self || item instanceof metadata_1.SkipSelf) {
                        r.visibility = item;
                    }
                    else if (item instanceof metadata_1.Optional) {
                        r.optional = true;
                    }
                    else {
                        r.injectKey = item;
                    }
                }
            }
            if (typeof r.injectKey === 'undefined') {
                throw new Error("The " + index + " th dependent parameter type of `" + stringify_1.stringify(provide) + "` was not obtained,\nif the dependency is declared later, you can refer to it using `constructor(@Inject(forwardRef(() => [Type|InjectionToken])) paramName: [Type]) {}`");
            }
            return r;
        });
    }
});
