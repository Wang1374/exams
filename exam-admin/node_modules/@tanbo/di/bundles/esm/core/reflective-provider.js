import { InjectFlags } from './injector';
import { Inject, Optional, Self, SkipSelf } from './metadata';
import { getAnnotations } from './decorators';
import { stringify } from './utils/stringify';
import { Injectable } from './injectable';
import { InjectionToken } from './injection-token';
/**
 * 标准化 provide，并返回统一数据结构
 * @param provider
 */
export function normalizeProvider(provider) {
    if (provider.useValue) {
        return normalizeValueProviderFactory(provider);
    }
    if (provider.useClass) {
        return normalizeClassProviderFactory(provider);
    }
    if (provider.useExisting) {
        return normalizeExistingProviderFactory(provider);
    }
    if (provider.useFactory) {
        return normalizeFactoryProviderFactory(provider);
    }
    if (provider.provide) {
        if (provider.provide instanceof InjectionToken) {
            return normalizeValueProviderFactory(provider);
        }
        return normalizeConstructorProviderFactory(provider);
    }
    return normalizeTypeProviderFactory(provider);
}
function normalizeValueProviderFactory(provider) {
    return {
        provide: provider.provide,
        scope: null,
        generateFactory() {
            return function () {
                return provider.useValue;
            };
        },
        deps: []
    };
}
function normalizeClassProviderFactory(provider) {
    let deps;
    let provideIn;
    if (provider.deps) {
        deps = normalizeDeps(provider.provide, provider.deps);
    }
    else {
        const resolvedClass = resolveClassParams(provider.useClass);
        provideIn = resolvedClass.scope;
        deps = normalizeDeps(provider.provide, resolvedClass.deps);
    }
    return {
        provide: provider.provide,
        scope: provideIn,
        deps,
        generateFactory(injector, cacheFn) {
            return function (...args) {
                if (provider.provide !== provider.useClass) {
                    const cachedInstance = injector.get(provider.useClass, null, InjectFlags.Optional);
                    if (cachedInstance) {
                        return cachedInstance;
                    }
                }
                const instance = new provider.useClass(...args);
                const propMetadataKeys = getAnnotations(provider.useClass).getPropMetadataKeys();
                propMetadataKeys.forEach(key => {
                    const propsMetadata = getAnnotations(provider.useClass).getPropMetadata(key) || [];
                    propsMetadata.forEach(item => {
                        item.contextCallback(instance, item.propertyKey, injector);
                    });
                });
                cacheFn(provider.provide, instance);
                if (provider.provide !== provider.useClass) {
                    cacheFn(provider.useClass, instance);
                }
                return instance;
            };
        }
    };
}
function normalizeExistingProviderFactory(provider) {
    return {
        provide: provider.provide,
        scope: null,
        generateFactory(injector) {
            return function () {
                return injector.get(provider.useExisting);
            };
        },
        deps: []
    };
}
function normalizeFactoryProviderFactory(provider) {
    return {
        provide: provider.provide,
        scope: null,
        generateFactory() {
            return function (...args) {
                return provider.useFactory(...args);
            };
        },
        deps: normalizeDeps(provider.provide, provider.deps || [])
    };
}
function normalizeConstructorProviderFactory(provider) {
    return normalizeClassProviderFactory(Object.assign(Object.assign({}, provider), { useClass: provider.provide }));
}
function normalizeTypeProviderFactory(provider) {
    return normalizeClassProviderFactory({
        provide: provider,
        useClass: provider
    });
}
function resolveClassParams(construct) {
    const annotations = getAnnotations(construct);
    const metadata = annotations.getClassMetadata(Injectable);
    if (typeof metadata === 'undefined') {
        throw new Error(`Class \`${stringify(construct)}\` is not injectable!`);
    }
    const deps = (metadata.paramTypes || []).map(i => [i]);
    const metadataKeys = [Inject, Self, SkipSelf, Optional];
    metadataKeys.forEach(key => {
        (annotations.getParamMetadata(key) || []).forEach(item => {
            deps[item.parameterIndex].push(item.metadata);
        });
    });
    return {
        scope: metadata.metadata.provideIn,
        deps
    };
}
function normalizeDeps(provide, deps) {
    return deps.map((dep, index) => {
        const r = {
            injectKey: null,
            optional: false,
            visibility: null
        };
        if (!Array.isArray(dep)) {
            r.injectKey = dep;
        }
        else {
            for (let i = 0; i < dep.length; i++) {
                const item = dep[i];
                if (item instanceof Inject) {
                    r.injectKey = item.token;
                }
                else if (item instanceof Self || item instanceof SkipSelf) {
                    r.visibility = item;
                }
                else if (item instanceof Optional) {
                    r.optional = true;
                }
                else {
                    r.injectKey = item;
                }
            }
        }
        if (typeof r.injectKey === 'undefined') {
            throw new Error(`The ${index} th dependent parameter type of \`${stringify(provide)}\` was not obtained,
if the dependency is declared later, you can refer to it using \`constructor(@Inject(forwardRef(() => [Type|InjectionToken])) paramName: [Type]) {}\``);
        }
        return r;
    });
}
