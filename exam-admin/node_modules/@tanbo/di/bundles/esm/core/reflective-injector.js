import { InjectFlags, Injector } from './injector';
import { normalizeProvider } from './reflective-provider';
import { Self, SkipSelf } from './metadata';
import { madeProvideScopeError, makeInjectError } from './utils/inject-error';
import { ForwardRef } from './forward-ref';
import { InjectionToken } from './injection-token';
import { NullInjector, THROW_IF_NOT_FOUND } from './null-injector';
import { Injectable } from './injectable';
import { getAnnotations } from './decorators';
const reflectiveInjectorErrorFn = makeInjectError('ReflectiveInjectorError');
const provideScopeError = madeProvideScopeError('ReflectiveInjectorError');
/**
 * 反射注入器
 */
export class ReflectiveInjector extends Injector {
    constructor(parentInjector, staticProviders, scope) {
        super();
        this.parentInjector = parentInjector;
        this.staticProviders = staticProviders;
        this.scope = scope;
        this.recordValues = new Map();
        this.normalizedProviders = staticProviders.map(provide => {
            return normalizeProvider(provide);
        });
    }
    /**
     * 用于获取当前注入器上下文内的实例、对象或数据
     * @param token 访问 token
     * @param notFoundValue 如未查找到的返回值
     * @param flags 查询规则
     */
    get(token, notFoundValue = THROW_IF_NOT_FOUND, flags) {
        var _a;
        flags = flags || InjectFlags.Default;
        if (flags === InjectFlags.SkipSelf) {
            if (this.parentInjector) {
                return this.parentInjector.get(token, notFoundValue);
            }
            if (notFoundValue !== THROW_IF_NOT_FOUND) {
                return notFoundValue;
            }
            throw reflectiveInjectorErrorFn(token);
        }
        if (this.recordValues.has(token)) {
            return this.recordValues.get(token);
        }
        for (let i = 0; i < this.normalizedProviders.length; i++) {
            const normalizedProvider = this.normalizedProviders[i];
            if (normalizedProvider.provide === token) {
                return this.getValue(token, notFoundValue, normalizedProvider);
            }
        }
        if (!(token instanceof InjectionToken)) {
            const scope = (_a = getAnnotations(token).getClassMetadata(Injectable)) === null || _a === void 0 ? void 0 : _a.metadata.provideIn;
            if (scope) {
                const normalizedProvider = normalizeProvider(token);
                if (this.scope === scope) {
                    this.normalizedProviders.push(normalizedProvider);
                    return this.getValue(token, notFoundValue, normalizedProvider);
                }
                const parentInjector = this.parentInjector;
                if (!parentInjector || parentInjector instanceof NullInjector) {
                    if (normalizedProvider.scope === 'root') {
                        this.normalizedProviders.push(normalizedProvider);
                        return this.getValue(token, notFoundValue, normalizedProvider);
                    }
                    if (notFoundValue !== THROW_IF_NOT_FOUND) {
                        return notFoundValue;
                    }
                    throw provideScopeError(normalizedProvider.scope);
                }
            }
        }
        if (flags === InjectFlags.Self) {
            if (notFoundValue === THROW_IF_NOT_FOUND) {
                throw reflectiveInjectorErrorFn(token);
            }
            return notFoundValue;
        }
        if (this.parentInjector) {
            return this.parentInjector.get(token, notFoundValue, flags === InjectFlags.Optional ? InjectFlags.Optional : InjectFlags.Default);
        }
        if (notFoundValue === THROW_IF_NOT_FOUND) {
            throw reflectiveInjectorErrorFn(token);
        }
        return notFoundValue;
    }
    getValue(token, notFoundValue = THROW_IF_NOT_FOUND, normalizedProvider) {
        const { generateFactory, deps } = normalizedProvider;
        const factory = generateFactory(this, (token, value) => {
            this.recordValues.set(token, value);
        });
        const params = this.resolveDeps(deps || [], notFoundValue);
        const value = factory(...params);
        this.recordValues.set(token, value);
        return value;
    }
    /**
     * 解决并获取依赖参数
     * @param deps 依赖规则
     * @param notFoundValue 未查找到时的返回值
     * @private
     */
    resolveDeps(deps, notFoundValue) {
        return deps.map(dep => {
            let reflectiveValue;
            const tryValue = {};
            const injectToken = dep.injectKey instanceof ForwardRef ? dep.injectKey.getRef() : dep.injectKey;
            if (dep.visibility instanceof Self) {
                reflectiveValue = this.get(injectToken, tryValue, InjectFlags.Self);
            }
            else if (dep.visibility instanceof SkipSelf) {
                if (this.parentInjector) {
                    reflectiveValue = this.parentInjector.get(injectToken, tryValue);
                }
                else {
                    if (dep.optional) {
                        if (notFoundValue === THROW_IF_NOT_FOUND) {
                            return null;
                        }
                    }
                    throw reflectiveInjectorErrorFn(injectToken);
                }
            }
            else {
                reflectiveValue = this.get(injectToken, tryValue);
            }
            if (reflectiveValue === tryValue) {
                if (dep.optional) {
                    if (notFoundValue === THROW_IF_NOT_FOUND) {
                        return null;
                    }
                    return notFoundValue;
                }
                throw reflectiveInjectorErrorFn(injectToken);
            }
            return reflectiveValue;
        });
    }
}
